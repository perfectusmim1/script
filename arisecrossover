--[[
	WARNING: Heads up! This script has not been verified by ScriptBlox. Use at your own risk!
]]
if Fluent then
    Fluent:Destroy()
end

local perfectusfolder = "PerfectusHubv2"
local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local TweenService = game:GetService("TweenService")
local TeleportService = game:GetService("TeleportService")
local VirtualUser = game:GetService("VirtualUser")
local workspace = game:GetService("Workspace")
local LocalPlayer = game:GetService("Players").LocalPlayer
local Inventory = LocalPlayer:FindFirstChild("leaderstats") and LocalPlayer.leaderstats:FindFirstChild("Inventory")
local player = game:GetService("Players").LocalPlayer
local character = player.Character or player.CharacterAdded:Wait()
local humanoidRootPart = character:WaitForChild("HumanoidRootPart")
local hrp = character:WaitForChild("HumanoidRootPart")
local enemiesFolder = workspace:WaitForChild("__Main"):WaitForChild("__Enemies"):WaitForChild("Client")
local dungeonFolder = workspace:WaitForChild("__Main"):WaitForChild("__Dungeon")
local remote = game:GetService("ReplicatedStorage").BridgeNet2.dataRemoteEvent
local AppearFolder = workspace:FindFirstChild("__Extra") and workspace.__Extra:FindFirstChild("__Appear")
local userFolder = workspace.__Main.__Pets:WaitForChild(tostring(LocalPlayer.UserId))
local PET_FOLDER = userFolder:GetChildren()
local PET_EVENT = require(game:GetService("ReplicatedStorage").BridgeNet2).ReferenceBridge("PET_EVENT")
local infshadow = game:GetService("Players").LocalPlayer.leaderstats.PlayerStats
local degisiklik2 = "\005"
local orosbucocugu = "\010"
local winterServerHopEnabled = false
local winterServerPreference = "Low Player Server"
local WINTER_CFRAME = CFrame.new(4755.91406,29.7264385,-2026.7511)
local WINTER_CFRAME2 = CFrame.new(4856.24707, 29.7264633, -2101.28369, 0.373035252, -3.37695298e-07, -0.927817166, 2.59595424e-07, 1, -2.59595367e-07, 0.927817166, -1.4401887e-07, 0.373035252)
local ignoredWinterMobs = {}
local winterEndBoss = "Snow Monarch"

local function sendAttackCommand(targetName, ariseToggle)
    local dataRemoteEvent = ReplicatedStorage:WaitForChild("BridgeNet2"):WaitForChild("dataRemoteEvent")

    if ariseToggle then
        LocalPlayer:SetAttribute("PetsArise", false)
        task.wait(0.02)
        LocalPlayer:SetAttribute("PetsArise", true)
        task.wait(0.02)
    end

    local trialKeys = {"\004", "\005", "\006", "\007", "\008", "\009", "\010", "\011", "\012"}

    for _, key in ipairs(trialKeys) do
        local args = {
            [1] = {
                [1] = {
                    ["PetPos"] = {},
                    ["AttackType"] = "All",
                    ["Event"] = "Attack",
                    ["Enemy"] = targetName
                },
                [2] = key
            }
        }

        dataRemoteEvent:FireServer(unpack(args))
        task.wait(0.1)
    end
end


local function teleportPetsToTargetPart(targetPart)
    if not targetPart or not targetPart:IsA("BasePart") then
        warn("Geçersiz targetPart! Bir BasePart olmalı.")
        return
    end

    local petsFolder = game.Workspace:FindFirstChild("__Main") and game.Workspace.__Main:FindFirstChild("__Pets")
    if not petsFolder then
        warn("__Pets klasörü bulunamadı!")
        return
    end

    for _, userIdFolder in pairs(petsFolder:GetChildren()) do
        if userIdFolder:IsA("Folder") then
            for _, petFolder in pairs(userIdFolder:GetChildren()) do
                if petFolder:IsA("Folder") then
                    for _, model in pairs(petFolder:GetChildren()) do
                        if model:IsA("Model") then
                            if not model.PrimaryPart then
                                local humanoidRootPart = model:FindFirstChild("HumanoidRootPart")
                                if humanoidRootPart then
                                    model.PrimaryPart = humanoidRootPart
                                else
                                    warn(model.Name .. " modelinde HumanoidRootPart bulunamadı!")
                                    continue
                                end
                            end
                            local targetCFrame = targetPart.CFrame * CFrame.new(0, model.PrimaryPart.Position.Y - targetPart.Position.Y, 0)
                            model:SetPrimaryPartCFrame(targetCFrame)
                            print(model.Name .. " modeli teleport edildi: " .. tostring(targetCFrame))
                        end
                    end
                end
            end
        end
    end
end

local function loadLibrary()
    local Library = loadstring(game:HttpGet("https://github.com/1dontgiveaf/Fluent/releases/latest/download/main.lua"))()
    task.wait(0.1)
    local SaveManager = loadstring(game:HttpGet("https://raw.githubusercontent.com/1dontgiveaf/Fluent/main/Addons/SaveManager.lua"))()
    task.wait(0.1)
    local InterfaceManager = loadstring(game:HttpGet("https://raw.githubusercontent.com/1dontgiveaf/Fluent/main/Addons/InterfaceManager.lua"))()
    return Library, SaveManager, InterfaceManager
end

local Library, SaveManager, InterfaceManager = loadLibrary()

local teleportEnabled = false
local teleportingEnabled = false
local castleFarmEnabled = false
local autoFarmV2Enabled = false
local autoRankEnabled = false
local autoEquipEnabled = false
local damageEnabled = false
local DelayToggle = false
local autoPotionEnabled = false
local killedNPCs = {}
local dungeonkill = {}
local castlekill = {}
local targetedEnemies = {}
local selectedMobName = ""
local movementMethod = "Teleport"
local farmingStyle = "Normal"
local selectedWorlds = {}
local selectedRanks = {}
local selectedDungeonTypes = {}
local autoBuyTicketEnabled = false
local selectedPotions = {}
local selectedMobTypes = {}
local targetFloor = 100
local maxDistance = 120
local CastleDelay = 0.7
local DungeonDelay = 0.7
local DungeonDelay2 = 6
local SelectedLevel = 1
local castleFarmMethod = "Teleport"
local castleTweenSpeed = 0.7
local dungeonFarmMethod = "Teleport"
local dungeonTweenSpeed = 0.7
local mainTweenSpeed = 0.7
local ariseDestroyDelay = 0.1
local autoUseDungeonRune = false
local autoUseDungeonRejoinRune = false
local autoResetCastleEnabled = false
local castleBossPriorityEnabled = false
local selectedDungeonRunes = {}
local castleDungeonExitMode = "Wait for Dungeon to End"
local autoExitDungeonForCastle = false
local autoLoadCheckpointsCastle = true
local webhookUrl = ""
local webhookEnabled = false
local winterFarmEnabled    = false
local winterFarmMethod     = "Teleport"
local winterTweenSpeed     = 0.7
local winterWalkSpeed      = 32
local winterFarmDelay      = 1
local savedWinterPosition  = nil
local autoReturnEnabled    = false
local disableDungeonDuringWinter = false
local disableCastleDuringWinter = false
local isWinterActive = false
local selectedCheckpoint = "False"
local checkpointsEnabled = false

local POTION_TYPES = {
    "ExpPotion",
    "GemsPotion",
    "DropsPotion", 
    "CoinsPotion",
    "ShadowPotion"
}

local MOB_TYPES = {
    "Normal",
    "Big"
}

local rankMapping = {
    ["E"] = 1,
    ["D"] = 2,
    ["C"] = 3,
    ["B"] = 4,
    ["A"] = 5,
    ["S"] = 6,
    ["SS"] = 7
}

local function getRankLetter(numRank)
    for letter, number in pairs(rankMapping) do
        if number == numRank then
            return letter
        end
    end
    return "Unknown"
end

local villageSpawns = {
    ["Leveling City"] = "SoloWorld",
    ["Grass Village"] = "NarutoWorld",
    ["Brum Island"] = "OPWorld",
    ["Faceheal Town"] = "BleachWorld",
    ["Lucky Kingdom"] = "BCWorld",
    ["Nipon City"] = "ChainsawWorld",
    ["Mori Town"] = "JojoWorld",
    ["Dragon Ball"] = "DBWorld",
    ["One Punch"] = "OPMWorld",
    ["Kindama City"] = "DanWorld",
    ["Hunters City"] = "Solo2World"
}

local dungeonSpawns = {
    ["BCWorld"] = "Lucky Kingdom",
    ["SoloWorld"] = "Leveling City",
    ["NarutoWorld"] = "Grass Village",
    ["OPWorld"] = "Brum Island",
    ["BleachWorld"] = "Faceheal Town",
    ["ChainsawWorld"] = "Nipon City",
    ["JojoWorld"] = "Mori Town",
    ["DBWorld"] = "Dragon Ball",
    ["OPMWorld"] = "One Punch",
    ["DanWorld"] = "Kindama City",
    ["Solo2World"] = "Hunters City"
}


local customCFrames = {
    ["Mori Town"] = CFrame.new(5462.841796875, 40.822052001953125, -132.9186553955078),
    ["Nipon City"] = CFrame.new(199.8670196533203, 33.89651107788086, -5077.17626953125),
    ["Faceheal Town"] = CFrame.new(2990.454833984375, 68.84293365478516, -3085.167724609375),
    ["Lucky Kingdom"] = CFrame.new(76.28400421142578, 37.8531494140625, 4911.29150390625),
    ["Dragon Ball"] = CFrame.new(-6933.37256, 124.132904, -64.2621765, -0.548029363, -2.10871889e-08, 0.8364591, 5.39440421e-08, 1, 6.05529991e-08, -0.8364591, 7.83068117e-08, -0.548029363)
}


local function sendWebhookMessage(message, dungeonData)
    print("[DEBUG] Webhook function called with message:", message)
    
    if not _G.webhookEnabled or _G.webhookUrl == "" then
        print("[DEBUG] Webhook not sent - disabled or empty URL")
        return false
    end

    local dungeonClears = "0"
    local success, clearCount = pcall(function()
        return game:GetService("Players").LocalPlayer.leaderstats.GeneralStats:GetAttribute("DungeonClear") or 0
    end)
    
    if success then
        dungeonClears = tostring(clearCount)
    else
        print("[DEBUG] Failed to get dungeon clear count:", clearCount)
    end

    local data = {
        ["content"] = "",
        ["embeds"] = {
            {
                ["title"] = "Dungeon Join",
                ["description"] = message,
                ["color"] = tonumber("0x" .. "800080"),
                ["thumbnail"] = {
                    ["url"] = "https://i.imgur.com/HEEC8jd.png"
                },
                ["fields"] = {
                    {
                        ["name"] = "Game",
                        ["value"] = game:GetService("MarketplaceService"):GetProductInfo(game.PlaceId).Name,
                        ["inline"] = true
                    },
                    {
                        ["name"] = "Player",
                        ["value"] = game.Players.LocalPlayer.Name,
                        ["inline"] = true
                    },
                    {
                        ["name"] = "Time",
                        ["value"] = os.date("%Y-%m-%d %H:%M:%S"),
                        ["inline"] = true
                    }
                },
                ["footer"] = {
                    ["text"] = "Total Dungeon Clears: " .. dungeonClears,
                    ["icon_url"] = "https://i.imgur.com/XOANIHC.png"
                },
                ["timestamp"] = DateTime.now():ToIsoDate()
            }
        }
    }

    local headers = {
        ["Content-Type"] = "application/json"
    }
    
    print("[DEBUG] Sending enhanced webhook...")
    
    local success, response = pcall(function()
        request({
            Url = _G.webhookUrl,
            Method = "POST",
            Headers = headers,
            Body = game:GetService("HttpService"):JSONEncode(data)
        })
    end)
    
    if success then
        print("[DEBUG] Webhook sent successfully!")
        return true
    else
        print("[DEBUG] Failed to send webhook. Error:", response)
        return false
    end
end

local function anticheat()
    local player = game.Players.LocalPlayer
    if player and player.Character then
        local characterScripts = player.Character:FindFirstChild("CharacterScripts")
        if characterScripts then
            local flyingFixer = characterScripts:FindFirstChild("FlyingFixer")
            if flyingFixer then
                flyingFixer:Destroy()
            end
            local characterUpdater = characterScripts:FindFirstChild("CharacterUpdater")
            if characterUpdater then
                characterUpdater:Destroy()
            end
        end
    end
end

local function isEnemyDead(enemy)
    local healthBar = enemy:FindFirstChild("HealthBar")
    if healthBar and healthBar:FindFirstChild("Main") and healthBar.Main:FindFirstChild("Bar") then
        local amount = healthBar.Main.Bar:FindFirstChild("Amount")
        if amount and amount:IsA("TextLabel") and amount.ContentText == "0 HP" then
            return true
        end
    end
    return false
end

local function saveCastleReturnCFrame(cframe)
    if writefile then
        local components = {cframe:GetComponents()}
        local str = table.concat(components, ",")
        writefile("castle_return_cframe.txt", str)
    end
end

local function loadCastleReturnCFrame()
    if readfile and isfile and isfile("castle_return_cframe.txt") then
        local str = readfile("castle_return_cframe.txt")
        local nums = {}
        for num in string.gmatch(str, "([^,]+)") do
            table.insert(nums, tonumber(num))
        end
        if #nums == 12 then
            return CFrame.new(unpack(nums))
        end
    end
    return nil
end

local displayToFolder = {}

local selectedDungeonRune = nil
local function getRuneDropdownValues()
    local itemsFolder = player.leaderstats.Inventory:FindFirstChild("Items")
    local values = {}
    displayToFolder = {}

    if itemsFolder then
        for _, folder in ipairs(itemsFolder:GetChildren()) do
            if folder:IsA("Folder") and string.match(folder.Name, "Rune$") then
                local guiEntry = player.PlayerGui
                    :WaitForChild("__Disable")
                    :WaitForChild("Menus")
                    :WaitForChild("Inventory")
                    :WaitForChild("Main")
                    :WaitForChild("Lists")
                    :WaitForChild("Items")
                    :FindFirstChild(folder.Name)

                local displayName
                local amountText = "0"
                if guiEntry and guiEntry:FindFirstChild("Main") then
                    local main = guiEntry.Main
                    if main:FindFirstChild("Value") then
                        displayName = main.Value.Text
                    end
                    if main:FindFirstChild("Amount") then
                        amountText = main.Amount.Text
                    end
                end

                displayName = displayName or folder.Name
                local combinedName = displayName .. " | " .. amountText

                table.insert(values, combinedName)
                displayToFolder[combinedName] = folder.Name
            end
        end
    end
    return values
end

local castleReturnEnabled = false

local function getSpawnLocation(worldName)
    local spawnName = villageSpawns[worldName]
    if not spawnName then
        return nil
    end
    local spawnsFolder = workspace:FindFirstChild("__Extra") and workspace.__Extra:FindFirstChild("__Spawns")
    if not spawnsFolder then
        return nil
    end
    local spawnLocation = spawnsFolder:FindFirstChild(spawnName)
    if spawnLocation and spawnLocation:IsA("SpawnLocation") then
        return spawnLocation.CFrame
    end
    return nil
end

local function TweenTeleport()
    local rootPart = character:WaitForChild("HumanoidRootPart")
    local parts = {}
    for _, part in pairs(game.Workspace.__Main.__Enemies.Server:GetDescendants()) do
        if part:IsA("BasePart") then
            table.insert(parts, part)
        end
    end
    if (#parts > 0) then
        local randomPart = parts[math.random(1, #parts)]
        local targetCFrame = randomPart.CFrame
        local tweenInfo = TweenInfo.new(2, Enum.EasingStyle.Quad, Enum.EasingDirection.Out)
        local tween = TweenService:Create(rootPart, tweenInfo, {CFrame = targetCFrame})
        tween:Play()
        tween.Completed:Wait()
        print("Tween ile teleport edildi: " .. randomPart.Name .. " (" .. randomPart.ClassName .. ")")
    else
        warn("Workspace'te BasePart bulunamadı!")
    end
end

local function teleportToObject(object)
    if not object then
        print("[ERROR] teleportToObject: Object is nil!")
        return
    end
    print("[DEBUG] Attempting to teleport to dungeon part...")
    anticheat()
    local redDungeonPrimary = workspace.__Main.__Dungeon:FindFirstChild("Dungeon") and 
                              workspace.__Main.__Dungeon.Dungeon:FindFirstChild("DungeonRod2") and
                              workspace.__Main.__Dungeon.Dungeon.DungeonRod2:FindFirstChild("Primary")
    
    if redDungeonPrimary then
        print("[DEBUG] Red dungeon detected, teleporting to Primary part")
        hrp.CFrame = redDungeonPrimary.CFrame * CFrame.new(0, 2, 0)
    else
        print("[DEBUG] Regular dungeon, teleporting to dungeon part")
    hrp.CFrame = object.CFrame * CFrame.new(0, 2, 0)
end
    
    task.wait(0.5)

    local dungeonPart = workspace.__Main.__Dungeon:WaitForChild("Dungeon", 2)
    if not dungeonPart then
        print("[ERROR] Could not find Dungeon part after teleport!")
        return
    end

    print("[DEBUG] Found dungeon part at", dungeonPart:FindFirstChild("DoubleDungeonSpawn") and dungeonPart.DoubleDungeonSpawn.Position or "No DoubleDungeonSpawn found")
    task.wait(0.5)

    if autoBuyTicketEnabled then
        local dungeonIcon =
            player.PlayerGui:FindFirstChild("Menus") and player.PlayerGui.Menus:FindFirstChild("Dungeon") and
            player.PlayerGui.Menus.Dungeon:FindFirstChild("Background") and
            player.PlayerGui.Menus.Dungeon.Background:FindFirstChild("DungeonIcon") and
            player.PlayerGui.Menus.Dungeon.Background.DungeonIcon:FindFirstChild("Completed")
        if dungeonIcon and dungeonIcon.Visible then
            print("[DEBUG] Ticket completed, buying new ticket...")
            local args = {
                [1] = {
                    [1] = {
                        ["Type"] = "Gems",
                        ["Action"] = "BuyTicket",
                        ["Event"] = "DungeonAction"
                    },
                    [2] = orosbucocugu
                }
            }
            remote:FireServer(unpack(args))
            task.wait(1)
        else
            print("[DEBUG] Ticket not completed, skipping purchase...")
        end
    end
    

    print("[DEBUG] Creating dungeon...")
local args = {
    [1] = {
        [1] = {
            ["Action"] = "Create",
            ["Event"] = "DungeonAction"
        },
        [2] = orosbucocugu
    }
}

game:GetService("ReplicatedStorage").BridgeNet2.dataRemoteEvent:FireServer(unpack(args))

    task.wait(0.3)

if autoUseDungeonRune == true and #selectedDungeonRunes > 0 then
    print("[DEBUG] Adding runes:", table.concat(selectedDungeonRunes, ", "))

    local allRuneSlots = {}
    local slot = 1

    for _, runeName in ipairs(selectedDungeonRunes) do
        for i = 1, 6 do
            table.insert(allRuneSlots, {
                slot = slot,
                name = runeName
            })
            slot += 1
        end
    end

    for i = 1, #allRuneSlots, 3 do
        for j = 0, math.min(2, #allRuneSlots - i) do
            local runeData = allRuneSlots[i + j]
            local addArgs = {
                [1] = {
                    [1] = {
                        ["Dungeon"] = player.UserId,
                        ["Action"] = "AddItems",
                        ["Slot"] = runeData.slot,
                        ["Event"] = "DungeonAction",
                        ["Item"] = runeData.name
                    },
                    [2] = orosbucocugu
                }
            }
            remote:FireServer(unpack(addArgs))
        end
        task.wait(0.05)
    end
    
    print("[DEBUG] Finished adding all runes in batches")
end
    task.wait(0.5)
    print("[DEBUG] Starting dungeon...")
    local startArgs = {
        [1] = {
            [1] = {
                ["Dungeon"] = player.UserId,
                ["Action"] = "Start",
                ["Event"] = "DungeonAction"
            },
            [2] = orosbucocugu
        }
    }
    remote:FireServer(unpack(startArgs))
end

local function isDungeonTime()
    local t = os.date("*t")
    local totalSeconds = t.min * 60 + t.sec
    local mod15 = totalSeconds % 900 
    local isActive = true
    local secondsUntilNextOpen = 0
    if mod15 >= 870 then
        isActive = false
        secondsUntilNextOpen = 900 - mod15
    end
    return isActive, secondsUntilNextOpen
end

local function isCastleTimeGlobal()
    local utc = os.date("!*t")
    local minute = utc.min
    if minute >= 45 and minute < 57 then
        return true
    end
    return false
end

local function searchDungeon(method)
    if method == "Teleport" then
        local lastWebhookTime = 0
        while teleportingEnabled do
            if game.PlaceId == 128336380114944 then
                print("[DEBUG] In dungeon, pausing search until exit.")
                task.wait(5)
            else
                local isActive, minutesUntil = isDungeonTime()

                if isActive then
                    local dungeonFound = false
                    for _, worldName in pairs(selectedWorlds) do
                        if not teleportingEnabled then break end

                        local spawnLocation = getSpawnLocation(worldName)
                        if spawnLocation then
                            print("[DEBUG] Teleporting to", worldName)
                            anticheat()
                            task.wait(1)

                            local dungeonPart = workspace.__Main.__Dungeon:WaitForChild("Dungeon", 1)
                            if dungeonPart then
                                local isRedDungeon = dungeonPart:GetAttribute("IsRedDungeon") == true
                                local dungeonMapName = dungeonPart:GetAttribute("MapName")
                                local dungeonWorldName = dungeonSpawns[dungeonMapName]

                                local typeMatch = (isRedDungeon and table.find(selectedDungeonTypes, "Red Dungeon"))
                                               or (not isRedDungeon and table.find(selectedDungeonTypes, "Normal Dungeon"))
                                if typeMatch then
                                    print(isRedDungeon and "[DEBUG] Found Red Dungeon" or "[DEBUG] Found Normal Dungeon")
                                end

                                if dungeonWorldName and table.find(selectedWorlds, dungeonWorldName) and typeMatch then
                                    print("[DEBUG] Dungeon world matches: " .. dungeonWorldName)

                                    local foundRank = dungeonPart:GetAttribute("DungeonRank")
                                    local rankMatch = false
                                    if foundRank and #selectedRanks > 0 then
                                        for _, selRank in ipairs(selectedRanks) do
                                            if rankMapping[selRank] == foundRank then
                                                rankMatch = true
                                                break
                                            end
                                        end
                                    end

                                    if rankMatch then
                                        print("[DEBUG] Rank matched:", foundRank)

                                        anticheat()
                                        task.wait(0.1)

                                        local currentTime = os.time()
                                        if _G.webhookEnabled and _G.webhookUrl ~= "" and (currentTime - lastWebhookTime) > 30 then
                                            local rankLetter = getRankLetter(foundRank)
                                            
                                            local dungeonData = {
                                                world = dungeonWorldName,
                                                type = isRedDungeon and "Red Dungeon" or "Normal Dungeon",
                                                rank = rankLetter
                                            }
                                            
                                            local webhookMessage = string.format(
                                                "**Dungeon Found!**\nWorld: %s\nType: %s\nRank: %s",
                                                dungeonWorldName,
                                                dungeonData.type,
                                                rankLetter
                                            )
                                            if sendWebhookMessage(webhookMessage, dungeonData) then
                                                lastWebhookTime = currentTime
                                            end
                                        end

                                        if isRedDungeon then
                                            local redDungeonPrimary = dungeonPart:FindFirstChild("DungeonRod2") and
                                                                      dungeonPart.DungeonRod2:FindFirstChild("Primary")
                                            if redDungeonPrimary then
                                                print("[DEBUG] Teleporting to Red Dungeon Primary part")
                                                teleportToObject(redDungeonPrimary)
                                            else
                                                print("[DEBUG] Red Dungeon Primary part not found, attempting fallback teleport")
                                                teleportToObject(dungeonPart)
                                            end
                                        else
                                            print("[DEBUG] Teleporting to Normal Dungeon part")
                                            teleportToObject(dungeonPart)
                                        end

                                        dungeonFound = true
                                        break
                                    else
                                        print("[DEBUG] Dungeon rank does not match! Found:", foundRank, "Selected:", table.concat(selectedRanks, ", "))
                                    end
                                else
                                    print("[DEBUG] Dungeon world/type does not match selection. Found world:", dungeonWorldName)
                                    local _, secondsUntilNextOpen = isDungeonTime()
                                    print("[DEBUG] Waiting until next dungeon time in", secondsUntilNextOpen, "seconds")
                                    task.wait(secondsUntilNextOpen + 1)
                                    break
                                end
                            else
                                print("[DEBUG] No dungeon part found in", worldName)
                            end
                        else
                            print("[DEBUG] Could not find spawn location for", worldName)
                        end
                        task.wait(0.1)
                    end

                    if not dungeonFound then
                        print("[DEBUG] No matching dungeon found in any selected world")
                        local _, secondsUntilNextOpen = isDungeonTime()
                        print("[DEBUG] Waiting until next dungeon time in", secondsUntilNextOpen, "seconds")
                        task.wait(secondsUntilNextOpen + 1)
                    end                
                else
                    print("[DEBUG] Not dungeon time, waiting...")
                    local _, secondsUntilNextOpen = isDungeonTime()
                    task.wait(secondsUntilNextOpen + 1)
                end                
            end
            task.wait(0.1)
        end
    end
end

player.CharacterAdded:Connect(
    function(newCharacter)
        character = newCharacter
        hrp = newCharacter:WaitForChild("HumanoidRootPart")
    end
)

local function getNearestSelectedEnemy()
    if not selectedEnemyFoundTime or os.time() - selectedEnemyFoundTime > 1 then
        killedNPCs = {}
    end

    local nearestEnemy = nil
    local shortestDistance = math.huge
    local playerPosition = hrp.Position

    for _, enemy in ipairs(enemiesFolder:GetChildren()) do
        if enemy:IsA("Model") and enemy:FindFirstChild("HumanoidRootPart") then
            local healthBar = enemy:FindFirstChild("HealthBar")
            if healthBar and healthBar:FindFirstChild("Main") and healthBar.Main:FindFirstChild("Title") then
                local title = healthBar.Main.Title
                if title and title:IsA("TextLabel") and title.ContentText == selectedMobName and not killedNPCs[enemy.Name] then
                    local enemyPosition = enemy.HumanoidRootPart.Position
                    local distance = (playerPosition - enemyPosition).Magnitude
                    if distance < shortestDistance then
                        shortestDistance = distance
                        nearestEnemy = enemy
                    end
                end
            end
        end
    end

    if nearestEnemy then
        selectedEnemyFoundTime = os.time()
    end
    
    return nearestEnemy
end

local function isBossRoom()
    local roomLabel = player.PlayerGui and player.PlayerGui:FindFirstChild("Hud") and player.PlayerGui.Hud:FindFirstChild("UpContanier") and player.PlayerGui.Hud.UpContanier:FindFirstChild("Room")
    if not roomLabel then return false end
    local text = roomLabel.Text
    local current, total = text:match("Room:%s*(%d+)%s*/%s*(%d+)")
    return current and total and (current == total)
end

local function getAnyEnemy()
    for _, enemy in ipairs(enemiesFolder:GetChildren()) do
        if enemy:IsA("Model") and enemy:FindFirstChild("HumanoidRootPart") and not dungeonkill[enemy.Name] and not isEnemyDead(enemy) then
            local size = enemy.HumanoidRootPart.Size
            local mobType = ""

            if #selectedMobTypes > 0 then
                if size == Vector3.new(2, 2, 1) and table.find(selectedMobTypes, "Normal") then
                    return enemy
                elseif size == Vector3.new(4, 4, 2) and table.find(selectedMobTypes, "Big") then
                    return enemy
                end
            else
                return enemy
            end
        end
    end
    return nil
end

local function getAnyEnemyForCastle()
    if castleBossPriorityEnabled then
        local biggestEnemy = nil
        local biggestSize = Vector3.new(0,0,3)
        for _, enemy in ipairs(enemiesFolder:GetChildren()) do
            if enemy:IsA("Model") and enemy:FindFirstChild("HumanoidRootPart") and not castlekill[enemy.Name] and not isEnemyDead(enemy) then
                local size = enemy.HumanoidRootPart.Size
                if size.Magnitude > biggestSize.Magnitude then
                    biggestSize = size
                    biggestEnemy = enemy
                end
            end
        end
        if biggestEnemy then
            return biggestEnemy
        end
    end

    for _, enemy in ipairs(enemiesFolder:GetChildren()) do
        if
            enemy:IsA("Model") and enemy:FindFirstChild("HumanoidRootPart") and not castlekill[enemy.Name] and
                not isEnemyDead(enemy)
         then
            return enemy
        end
    end
    return nil
end

local function getNearestEnemy()
    local nearestEnemy, shortestDistance = nil, math.huge
    local playerPosition = hrp.Position

    for _, enemy in ipairs(enemiesFolder:GetChildren()) do
        if enemy:IsA("Model") and enemy:FindFirstChild("HumanoidRootPart") and not killedNPCs[enemy.Name] then
            local distance = (playerPosition - enemy:GetPivot().Position).Magnitude
            if distance < shortestDistance then
                shortestDistance = distance
                nearestEnemy = enemy
            end
        end
    end
    return nearestEnemy
end

local function getLowestHPEnemy()
    local lowestHPEnemy = nil
    local lowestHP = math.huge

    for _, enemy in ipairs(enemiesFolder:GetChildren()) do
        if
            enemy:IsA("Model") and enemy:FindFirstChild("HumanoidRootPart") and not targetedEnemies[enemy.Name] and
                not isEnemyDead(enemy)
         then
            local currentHP = tonumber(enemy.HealthBar.Main.Bar.Amount.ContentText:match("%d+")) or math.huge
            if currentHP < lowestHP then
                lowestHP = currentHP
                lowestHPEnemy = enemy
            end
        end
    end
    return lowestHPEnemy
end

local noclipConnection
local function enableNoclip()
    if noclipConnection then return end
    noclipConnection = game:GetService("RunService").Stepped:Connect(function()
        if movementMethod == "Walk" and character then
            for _, part in ipairs(character:GetDescendants()) do
                if part:IsA("BasePart") and part.CanCollide then
                    part.CanCollide = false
                end
            end
        end
    end)
end

local function disableNoclip()
    if noclipConnection then
        noclipConnection:Disconnect()
        noclipConnection = nil
    end
end


local function moveToTarget(target)
    if not target or not target:FindFirstChild("HumanoidRootPart") then return end
    local enemyHrp = target.HumanoidRootPart

    if movementMethod == "Teleport" then
        task.wait(0.03)
        hrp.CFrame = enemyHrp.CFrame * CFrame.new(0, 0, 6)
        task.wait(0.03)
    elseif movementMethod == "Tween" then
        local tweenInfo = TweenInfo.new(mainTweenSpeed, Enum.EasingStyle.Linear)
        local tween = TweenService:Create(hrp, tweenInfo, {CFrame = enemyHrp.CFrame * CFrame.new(0, 0, 6)})
        tween:Play()
        tween.Completed:Wait()
    elseif movementMethod == "Walk" then
        enableNoclip()
        local humanoid = hrp.Parent:FindFirstChildOfClass("Humanoid")
        if humanoid then
            humanoid:MoveTo((enemyHrp.CFrame * CFrame.new(0, 0, 4)).Position)
            local reached = false
            local conn
            conn = humanoid.MoveToFinished:Connect(function(success)
                reached = true
            end)
            local startTime = tick()
            while not reached and tick() - startTime < 3 do
                task.wait(0.05)
            end
            if conn then conn:Disconnect() end
        end
    end
end

local function isInCastle()
    local player = game:GetService("Players").LocalPlayer
    local hud = player.PlayerGui:FindFirstChild("Hud")
    if not hud then return false end
    local upContainer = hud:FindFirstChild("UpContanier")
    if not upContainer then return false end
    local room = upContainer:FindFirstChild("Room")
    if not room then return false end
    local text = room.Text
    local floor, maxFloor = text:match("Floor:%s*(%d+)%s*/%s*(%d+)")
    if maxFloor and tonumber(maxFloor) == 100 then
        return true
    end
    return false
end

local function isInDungeon()
    return game.PlaceId == 128336380114944 and not isInCastle()
end

local function teleportDungeon()
    if game.PlaceId ~= 128336380114944 then return end

    local bossRoomWaited = false

    while teleportEnabled do
        if isInCastle() and castleFarmEnabled then break end

        if isBossRoom() and not bossRoomWaited then
            Fluent:Notify({
                Title = "Boss Room",
                Content = "Boss room reached. Waiting " .. DungeonDelay2 .. " seconds before farming.",
                Duration = 3
            })
            task.wait(DungeonDelay2)
            bossRoomWaited = true
        elseif not isBossRoom() then
            bossRoomWaited = false
        end

        local target = getAnyEnemy()
        if target and target.Parent then
            anticheat()
            local enemyPos = target.HumanoidRootPart.Position
            local enemyCFrame = target.HumanoidRootPart.CFrame
            local targetCFrame = enemyCFrame * CFrame.new(0, 2, 6)

            if dungeonFarmMethod == "Tween" then
                local tweenInfo = TweenInfo.new(
                    dungeonTweenSpeed,
                    Enum.EasingStyle.Linear,
                    Enum.EasingDirection.Out
                )
                local tween = TweenService:Create(hrp, tweenInfo, {CFrame = targetCFrame})
                tween:Play()
                tween.Completed:Wait()
            else 
                task.wait(0.03) 
                hrp.CFrame = targetCFrame
                task.wait(0.03)
            end

            task.wait(0.05)
            sendAttackCommand(target.Name, true)
            task.wait(0.05)
            while target.Parent and not isEnemyDead(target) do
                task.wait(0.1)
            end
            dungeonkill[target.Name] = true

            if DungeonDelay and DungeonDelay > 0 then
                task.wait(DungeonDelay)
            end
        else
            local serverFolder = workspace.__Main.__Enemies.Server
            if serverFolder and #serverFolder:GetChildren() > 0 then
                local randomIndex = math.random(1, #serverFolder:GetChildren())
                local serverPart = serverFolder:GetChildren()[randomIndex]
                if serverPart then
                    print("[DEBUG] No mob found (Dungeon), teleporting to server part:", serverPart.Name)
                    anticheat()
                    hrp.CFrame = serverPart.CFrame * CFrame.new(0, 2, 6)
                    task.wait(0.05)
                    sendAttackCommand(serverPart.Name, true)
                    task.wait(1)
                else
                    warn("[ERROR] Invalid server part selected! Retrying...")
                    task.wait(0.5)
                end
            else
                warn("[ERROR] No server parts found! Retrying...")
                task.wait(0.5)
            end
        end
        task.wait(0.1)
    end
end

local function getCurrentFloor()
    local hudGui = player.PlayerGui:FindFirstChild("Hud") and player.PlayerGui.Hud:FindFirstChild("UpContanier")
    if hudGui and hudGui:FindFirstChild("Room") then
        local roomText = hudGui.Room.Text
        local floorNumber = tonumber(roomText:match("Floor: (%d+)/%d+")) or 0
        return floorNumber
    end
    return 0
end

local function checkFloorAndExit()
    while castleFarmEnabled do
        local currentFloor = getCurrentFloor()
        if currentFloor >= targetFloor then
            print("[DEBUG] Target floor", targetFloor, "reached, stopping farm...")
            castleFarmEnabled = false
            print("[DEBUG] Attempting to exit castle via teleport...")
            game:GetService("TeleportService"):Teleport(87039211657390, game.Players.LocalPlayer)
            Fluent:Notify({
                Title = "Castle Exited",
                Content = "Reached target floor " .. targetFloor .. " and exiting...",
                Duration = 5
            })

            task.spawn(function()
                task.wait(5)
                if castleReturnEnabled and game.PlaceId == 87039211657390 then
                    local cf = loadCastleReturnCFrame()
                    if cf and player.Character and player.Character:FindFirstChild("HumanoidRootPart") then
                        player.Character.HumanoidRootPart.CFrame = cf
                        Fluent:Notify({
                            Title = "Castle Return",
                            Content = "Teleported to saved position after castle.",
                            Duration = 3
                        })
                    end
                end
            end)
            return true
        end
        task.wait(0.1)
    end
    return false
end


local function checkFloorChangeAndTeleport()
    local previousFloor = getCurrentFloor()
    if previousFloor == 0 then
        print("[DEBUG] Could not determine current floor, skipping floor change check.")
        return false
    end

    print("[DEBUG] Monitoring floor change, current floor:", previousFloor)

    while castleFarmEnabled do
        local currentFloor = getCurrentFloor()
        if currentFloor > previousFloor then
            print("[DEBUG] Floor increased from", previousFloor, "to", currentFloor, ", teleporting to portal...")
            local roomName = "Room_" .. currentFloor
            local portal =
                workspace:FindFirstChild("__Main") and workspace.__Main:FindFirstChild("__World") and
                workspace.__Main.__World:FindFirstChild(roomName) and
                workspace.__Main.__World[roomName]:FindFirstChild("Portal")
            if portal and portal:IsA("BasePart") then
                print("[DEBUG] Portal found in", roomName, ", teleporting...")
                anticheat()
                hrp.CFrame = portal.CFrame * CFrame.new(0, 0, 3)
                task.wait(0.1)
                game:GetService("Players").LocalPlayer:SetAttribute("PetsArise", false)
                task.wait(0.05)
                game:GetService("Players").LocalPlayer:SetAttribute("PetsArise", true)

                local function allMobsDead()
                    for _, enemy in ipairs(enemiesFolder:GetChildren()) do
                        if enemy:IsA("Model") and enemy:FindFirstChild("HumanoidRootPart") and not isEnemyDead(enemy) then
                            return false
                        end
                    end
                    return true
                end
                while not allMobsDead() and castleFarmEnabled do
                    task.wait(0.1)
                end
                print("[DEBUG] Teleported to portal, all mobs dead, resetting castlekill table...")
                castlekill = {}
                previousFloor = currentFloor
            else
                print("[ERROR] Portal not found in", roomName, ", trying MainRoot.Part as fallback")
                local mainRootPart = workspace:FindFirstChild("__Main") and workspace.__Main:FindFirstChild("__World") and
                    workspace.__Main.__World:FindFirstChild(roomName) and
                    workspace.__Main.__World[roomName]:FindFirstChild("Buildings") and
                    workspace.__Main.__World[roomName].Buildings:FindFirstChild("MainRoot") and
                    workspace.__Main.__World[roomName].Buildings.MainRoot:FindFirstChild("Part")
                if mainRootPart and mainRootPart:IsA("BasePart") then
                    print("[DEBUG] Fallback MainRoot.Part found, teleporting...")
                    anticheat()
                    hrp.CFrame = mainRootPart.CFrame * CFrame.new(0, 0, 6)
                    task.wait(0.2)
                    sendAttackCommand(mainRootPart.Name, true)
                    task.wait(0.05)
                    local function allMobsDead()
                        for _, enemy in ipairs(enemiesFolder:GetChildren()) do
                            if enemy:IsA("Model") and enemy:FindFirstChild("HumanoidRootPart") and not isEnemyDead(enemy) then
                                return false
                            end
                        end
                        return true
                    end
                    while not allMobsDead() and castleFarmEnabled do
                        task.wait(0.2)
                    end
                    print("[DEBUG] Teleported to MainRoot.Part, all mobs dead, resetting castlekill table...")
                    castlekill = {}
                    previousFloor = currentFloor
                else
                    print("[ERROR] MainRoot.Part also not found in", roomName)
                    return false
                end
            end
        elseif currentFloor < previousFloor then
            print(
                "[DEBUG] Floor decreased unexpectedly from",
                previousFloor,
                "to",
                currentFloor,
                ", resetting check..."
            )
            previousFloor = currentFloor
        end
        task.wait(0.3)
    end
    return false
end

local function teleportCastleFarmMain()
    if game.PlaceId ~= 128336380114944 then
        return
    end

    task.spawn(checkFloorAndExit)
    task.spawn(checkFloorChangeAndTeleport)

    while castleFarmEnabled do

        if not isInCastle() and teleportEnabled then
            print("[DEBUG] Not in Castle, stopping castle farm.")
            break
        end
        local target = getAnyEnemyForCastle()
        if target and target.Parent and not isEnemyDead(target) then
            anticheat()
            local enemyPos = target.HumanoidRootPart.Position
            local enemyLook = target.HumanoidRootPart.CFrame.LookVector
            local teleportPos = enemyPos - (enemyLook * 3)
            local targetCFrame = CFrame.new(teleportPos, enemyPos)
            
            if castleFarmMethod == "Tween" then
                local tweenInfo = TweenInfo.new(
                    castleTweenSpeed,
                    Enum.EasingStyle.Linear,
                    Enum.EasingDirection.Out
                )
                local tween = TweenService:Create(hrp, tweenInfo, {CFrame = targetCFrame})
                tween:Play()
                tween.Completed:Wait()
            else
                hrp.CFrame = targetCFrame
            end
            task.wait(0.05)
            sendAttackCommand(target.Name, true)
            task.wait(0.05)
            while target.Parent and not isEnemyDead(target) do
                task.wait(0.1)
            end
            castlekill[target.Name] = true

            if CastleDelay and CastleDelay > 0 then
                task.wait(CastleDelay)
            end
        else
            local serverFolder = workspace.__Main.__Enemies.Server
            if serverFolder and #serverFolder:GetChildren() > 0 then
                local randomIndex = math.random(1, #serverFolder:GetChildren())
                local serverPart = serverFolder:GetChildren()[randomIndex]
                if serverPart then
                    print("[DEBUG] No mob found (Castle), teleporting to server part CFrame for castle:", serverPart.Name)
                    anticheat()
                    humanoidRootPart.CFrame = serverPart.CFrame * CFrame.new(0, 0, 6)
                    task.wait(0.05)
                    sendAttackCommand(serverPart.Name, true)
                    task.wait(0.05)
                else
                    print("[INFO] Server part selected but invalid for castle, waiting before retry...")
                    task.wait(1)
                end
            else
                local currentFloor = getCurrentFloor()
                local roomName = "Room_" .. tostring(currentFloor)
                local mainRootPart = workspace:FindFirstChild("__Main") and workspace.__Main:FindFirstChild("__World") and
                    workspace.__Main.__World:FindFirstChild(roomName) and
                    workspace.__Main.__World[roomName]:FindFirstChild("Buildings") and
                    workspace.__Main.__World[roomName].Buildings:FindFirstChild("MainRoot") and
                    workspace.__Main.__World[roomName].Buildings.MainRoot:FindFirstChild("Part")
                if mainRootPart and mainRootPart:IsA("BasePart") then
                    print("[INFO] No server parts found, teleporting to MainRoot.Part as fallback for castle:", roomName)
                    anticheat()
                    humanoidRootPart.CFrame = mainRootPart.CFrame
                    task.wait(0.05)
                    sendAttackCommand(mainRootPart.Name, true)
                    task.wait(0.6)
                else
                    print("[INFO] No server parts or MainRoot.Part found in the folder for castle, waiting before retry...")
                    task.wait(0.1)
                end
            end
        end
        task.wait(0.1)
    end
end

local function teleportToWorldSpawn(worldName)
    local spawnName = villageSpawns[worldName]
    if not spawnName then
        return false
    end
    local spawnsFolder = workspace:FindFirstChild("__Extra") and workspace.__Extra:FindFirstChild("__Spawns")
    if not spawnsFolder then
        return false
    end
    local spawnPart = spawnsFolder:FindFirstChild(spawnName)
    if not spawnPart or not spawnPart:IsA("BasePart") then
        return false
    end
    anticheat()
    hrp.CFrame = spawnPart.CFrame
    task.wait(0.5)
    return true
end

local function cframeToTable(cframe)
    return {
        x = cframe.X,
        y = cframe.Y,
        z = cframe.Z,
        lookVectorX = cframe.LookVector.X,
        lookVectorY = cframe.LookVector.Y,
        lookVectorZ = cframe.LookVector.Z,
        upVectorX = cframe.UpVector.X,
        upVectorY = cframe.UpVector.Y,
        upVectorZ = cframe.UpVector.Z
    }
end

local function tableToCFrame(tbl)
    return CFrame.new(
        tbl.x,
        tbl.y,
        tbl.z,
        tbl.lookVectorX,
        tbl.lookVectorY,
        tbl.lookVectorZ,
        tbl.upVectorX,
        tbl.upVectorY,
        tbl.upVectorZ
    )
end

local function searchLoop()
    local lastDungeonNotifyTime = 0
    local lastCastleNotifyTime = 0
    local lastTeleportTime = 0
    local notifyInterval = 180
    local teleportCooldown = 15 
    while true do
        local currentTime = tick()
        if teleportingEnabled then
            local isDungeonNow, secondsUntilNextDungeon = isDungeonTime()
            if isDungeonNow and (currentTime - lastTeleportTime) >= teleportCooldown then
                task.wait(1)
                lastTeleportTime = currentTime
            elseif not isDungeonNow and (currentTime - lastDungeonNotifyTime) >= notifyInterval then
                if teleportingEnabled and not castleFarmEnabled then
                    Fluent:Notify({
                        Title = "Dungeon Search",
                        Content = "Next dungeon in " .. math.floor(secondsUntilNextDungeon) .. "s",
                        Duration = 5
                    })
                    lastDungeonNotifyTime = currentTime
                end
            end
        elseif castleFarmEnabled then
            local isCastleNow, secondsUntilNextCastle = isCastleTimeGlobal()
            if isCastleNow then
                if game.PlaceId == 87039211657390 and (currentTime - lastTeleportTime) >= teleportCooldown then
                    local args = {
                        [1] = {
                            [1] = {
                                ["Check"] = checkpointsEnabled and selectedCheckpoint ~= "False",
                                ["Action"] = "Join",
                                ["Event"] = "CastleAction"
                            },
                            [2] = orosbucocugu
                        }
                    }
                    if checkpointsEnabled and selectedCheckpoint ~= "False" then
                        args[1][1]["Floor"] = selectedCheckpoint
                    end
                    game:GetService("ReplicatedStorage").BridgeNet2.dataRemoteEvent:FireServer(unpack(args))
                    lastTeleportTime = currentTime
                end
            else
                if (currentTime - lastCastleNotifyTime) >= notifyInterval then
                    lastCastleNotifyTime = currentTime
                end
            end
        end
        task.wait(0.3)
    end
end

local function teleportAndTrackDeath()
    while teleportEnabled do
        local target = getNearestEnemy()
        if target and target.Parent then
            anticheat()
            moveToTarget(target)
            task.wait(0.05)
            sendAttackCommand(target.Name, true)
            task.wait(0.05)
            while teleportEnabled and target.Parent and not isEnemyDead(target) do
                task.wait(0.1)
            end

            killedNPCs[target.Name] = true
        end
        task.wait(0.1)
    end
end

local function teleportToSelectedEnemy()
    local lastResetTime = os.time()
    
    while teleportEnabled do
        local target = nil
        
        if _G.selectedMobs and #_G.selectedMobs > 0 then
            _G.currentMobIndex = _G.currentMobIndex or 1

            local currentMobType = _G.selectedMobs[_G.currentMobIndex]
            local shortestDistance = math.huge
            local playerPosition = hrp.Position

            for _, enemy in ipairs(enemiesFolder:GetChildren()) do
                if enemy:IsA("Model") and enemy:FindFirstChild("HumanoidRootPart") then
                    local healthBar = enemy:FindFirstChild("HealthBar")
                    if healthBar and healthBar:FindFirstChild("Main") and healthBar.Main:FindFirstChild("Title") then
                        if healthBar.Main.Title.Text == currentMobType and not killedNPCs[enemy.Name] and not isEnemyDead(enemy) then
                            local size = enemy.HumanoidRootPart.Size
                            local isCorrectSize = true
                            
                            if #selectedMobTypes > 0 then
                                isCorrectSize = false
                                if size == Vector3.new(2, 2, 1) and table.find(selectedMobTypes, "Normal") then
                                    isCorrectSize = true
                                elseif size == Vector3.new(4, 4, 2) and table.find(selectedMobTypes, "Big") then
                                    isCorrectSize = true
                                end
                            end
                            
                            if isCorrectSize then
                                local distance = (playerPosition - enemy.HumanoidRootPart.Position).Magnitude
                                if distance < shortestDistance then
                                    shortestDistance = distance
                                    target = enemy
                                end
                            end
                        end
                    end
                end
            end

            if not target then
                _G.currentMobIndex = (_G.currentMobIndex % #_G.selectedMobs) + 1
            end
        end

        if not target and os.time() - lastResetTime > 1 then
            killedNPCs = {}
            lastResetTime = os.time()
            print("Reset killed NPCs list")
        end

        if target and target.Parent and not isEnemyDead(target) then
            anticheat()
            moveToTarget(target)
            task.wait(0.05)
            sendAttackCommand(target.Name, true)
            task.wait(0.05)
            while target.Parent and not isEnemyDead(target) do
                task.wait(0.1)
            end
            
            killedNPCs[target.Name] = true

            _G.mobKillCounts = _G.mobKillCounts or {}

            local mobName = "Unknown"
            if target:FindFirstChild("HealthBar") and 
               target.HealthBar:FindFirstChild("Main") and 
               target.HealthBar.Main:FindFirstChild("Title") then
                mobName = target.HealthBar.Main.Title.Text
            end
            
            _G.mobKillCounts[mobName] = (_G.mobKillCounts[mobName] or 0) + 1
            print("Killed", mobName, "- Total:", _G.mobKillCounts[mobName])
        end
        
        task.wait(delay)
    end
end

local function tweenToCFrame(targetCFrame)
    if not hrp then return end
    local tweenInfo = TweenInfo.new(mainTweenSpeed, Enum.EasingStyle.Linear)
    local tween = TweenService:Create(hrp, tweenInfo, {CFrame = targetCFrame})
    tween:Play()
    tween.Completed:Wait()
end

local function autoFarmV2()
    local lastResetTime = os.time()
    while autoFarmV2Enabled do
        if teleportEnabled then
            break
        end
        
        local target = nil
        
        if farmingStyle == "Normal" then
            target = getAnyEnemy()
        elseif farmingStyle == "Nearest" then
            local nearestDistance = math.huge
            local playerPosition = hrp.Position
            
            for _, enemy in ipairs(enemiesFolder:GetChildren()) do
                if enemy:IsA("Model") and enemy:FindFirstChild("HumanoidRootPart") and not targetedEnemies[enemy.Name] and not isEnemyDead(enemy) then
                    local size = enemy.HumanoidRootPart.Size
                    local isCorrectSize = true
                    
                    if #selectedMobTypes > 0 then
                        isCorrectSize = false
                        if size == Vector3.new(2, 2, 1) and table.find(selectedMobTypes, "Normal") then
                            isCorrectSize = true
                        elseif size == Vector3.new(4, 4, 2) and table.find(selectedMobTypes, "Big") then
                            isCorrectSize = true
                        end
                    end
                    
                    if isCorrectSize then
                        local distance = (playerPosition - enemy.HumanoidRootPart.Position).Magnitude
                        if distance < nearestDistance then
                            nearestDistance = distance
                            target = enemy
                        end
                    end
                end
            end
        elseif farmingStyle == "Highest HP" then
            local highestHP = 0
            
            for _, enemy in ipairs(enemiesFolder:GetChildren()) do
                if enemy:IsA("Model") and enemy:FindFirstChild("HumanoidRootPart") and not targetedEnemies[enemy.Name] and not isEnemyDead(enemy) then
                    local size = enemy.HumanoidRootPart.Size
                    local isCorrectSize = true
                    
                    if #selectedMobTypes > 0 then
                        isCorrectSize = false
                        if size == Vector3.new(2, 2, 1) and table.find(selectedMobTypes, "Normal") then
                            isCorrectSize = true
                        elseif size == Vector3.new(4, 4, 2) and table.find(selectedMobTypes, "Big") then
                            isCorrectSize = true
                        end
                    end
                    
                    if isCorrectSize then
                        local currentHP = tonumber(enemy.HealthBar.Main.Bar.Amount.ContentText:match("%d+")) or 0
                        if currentHP > highestHP then
                            highestHP = currentHP
                            target = enemy
                        end
                    end
                end
            end
        elseif farmingStyle == "Lowest HP" then
            target = getLowestHPEnemy()
        end
        
        if not target and os.time() - lastResetTime > 1 then
            targetedEnemies = {}
            lastResetTime = os.time()
            print("Reset killed monster list")
        end

        if target and target.Parent and not isEnemyDead(target) then
            anticheat()
            moveToTarget(target, false)
            task.wait(0.05)
            sendAttackCommand(target.Name, true)
            task.wait(0.05)
            while target.Parent and not isEnemyDead(target) do
                task.wait(0.1)
            end
            targetedEnemies[target.Name] = true
        end
        task.wait(delay)
    end
end

local function attackNearest()
    local Player_HumanoidRootPart = LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("HumanoidRootPart")
    if not Player_HumanoidRootPart then
        return
    end

    local nearestPlayer = nil
    local nearestDistance = math.huge

    for _, NPC in pairs(game.Workspace.__Main.__Enemies.Client:GetChildren()) do
        if NPC and NPC:FindFirstChild("HumanoidRootPart") then
            local healthBar = NPC:FindFirstChild("HealthBar")
            if
                healthBar and healthBar.Main and healthBar.Main.Bar and healthBar.Main.Bar.Amount and
                    healthBar.Main.Bar.Amount.Text ~= "0 HP"
             then
                local distance = (NPC.HumanoidRootPart.Position - Player_HumanoidRootPart.Position).Magnitude
                if distance < maxDistance and distance < nearestDistance then
                    nearestDistance = distance
                    nearestPlayer = NPC
                end
            end
        end
    end

    if nearestPlayer then
        task.wait(0.05)
        sendAttackCommand(nearestPlayer.Name, true)
        task.wait(0.05)
    end
end

local function getMobType(enemy)
    if enemy and enemy:FindFirstChild("HumanoidRootPart") then
        local size = enemy.HumanoidRootPart.Size
        if size.X == 2 and size.Y == 2 and size.Z == 1 then
            return "Normal"
        elseif size.X == 4 and size.Y == 4 and size.Z == 2 then
            return "Big" 
        end
    end
    return "Unknown"
end

local function getCurrentWorldName()
    local enemiesServerFolder = workspace:FindFirstChild("__Main") and workspace.__Main:FindFirstChild("__Enemies") and workspace.__Main.__Enemies:FindFirstChild("Server")
    if not enemiesServerFolder then return nil end
    local worldNames = {
        [1] = "Leveling City",
        [2] = "Grass Village",
        [3] = "Brum Island",
        [4] = "Faceheal Town",
        [5] = "Lucky Kingdom",
        [6] = "Nipon City",
        [7] = "Mori Town",
        [8] = "Dragon City",
        [9] = "XZ City"
    }
    for i = 1, 9 do
        local worldFolder = enemiesServerFolder:FindFirstChild(tostring(i))
        if worldFolder then
            for _, child in ipairs(worldFolder:GetChildren()) do
                if child:IsA("Part") then
                    return worldNames[i]
                end
            end
        end
    end
    return nil
end


local UserInputService = game:GetService("UserInputService")
local isMobile = UserInputService.TouchEnabled and not UserInputService.KeyboardEnabled

local windowSize = isMobile and UDim2.fromOffset(450, 300) or UDim2.fromOffset(525, 375)

local deviceType = isMobile and "Mobile" or "Computer"

local Window =
    Fluent:CreateWindow(
    {
        Title = game:GetService("MarketplaceService"):GetProductInfo(game.PlaceId).Name .. "  -  " .. deviceType,
        SubTitle = "By Perfectus",
        TabWidth = 135,
        Size = windowSize,
        Acrylic = false,
        Theme = "Perfectus",
        MinimizeKey = Enum.KeyCode.LeftControl
    }
)

local Tabs = {
    Updates = Window:AddTab({Title = "Updates", Icon = "http://www.roblox.com/asset/?id=100643227311924"}),
    Main = Window:AddTab({Title = "Main", Icon = "http://www.roblox.com/asset/?id=101029723441244"}),
    Winter = Window:AddTab({Title = "Winter", Icon = "http://www.roblox.com/asset/?id=105761433635743"}),
    dungeon = Window:AddTab({Title = "Dungeon", Icon = "http://www.roblox.com/asset/?id=94159588809272"}),
    castle = Window:AddTab({Title = "Castle", Icon = "http://www.roblox.com/asset/?id=83915833356289"}),
    Rank = Window:AddTab({Title = "Rank", Icon = "http://www.roblox.com/asset/?id=85503604796811"}),
    Exchange = Window:AddTab({Title = "Exchange", Icon = "http://www.roblox.com/asset/?id=77484367461047"}),
    Potion = Window:AddTab({Title = "Potion", Icon = "http://www.roblox.com/asset/?id=94258015983504"}),
    Level = Window:AddTab({Title = "Stats", Icon = "http://www.roblox.com/asset/?id=137048024127340"}),
    Webhook = Window:AddTab({Title = "Webhook", Icon = "http://www.roblox.com/asset/?id=125671980317396"}),
    tp = Window:AddTab({Title = "Teleports", Icon = "http://www.roblox.com/asset/?id=121248877953645"}),
    pets = Window:AddTab({Title = "Pets", Icon = "http://www.roblox.com/asset/?id=75110508198546"}),
    misc = Window:AddTab({Title = "Weapons", Icon = "http://www.roblox.com/asset/?id=72061049443754"}),
    Settings = Window:AddTab({Title = "Settings", Icon = "http://www.roblox.com/asset/?id=136391856776112"})
}

local Options = Fluent.Options

local function populateTabs()
    task.spawn(function()

        Tabs.Updates:AddSection("WEBSITE")
        Tabs.Updates:AddButton({
            Title = "Website Link",
            Description = "",
            Callback = function()
                setclipboard("https://perfectusmim1.github.io/websitem.github.io/")
                Fluent:Notify({
                    Title = "Perfectus",
                    Content = "Copied to clipboard!",
                    Duration = 3
                })
            end
        })
        
        Tabs.Updates:AddSection("DISCORD")
        Tabs.Updates:AddButton({
            Title = "Discord Link",
            Description = "",
            Callback = function()
                setclipboard("https://discord.com/invite/FcFkuF4xR3")
                Fluent:Notify({
                    Title = "Perfectus",
                    Content = "Copied to clipboard!",
                    Duration = 3
                })
            end
        })

        Tabs.Updates:AddSection("VERSION")
        Tabs.Updates:AddParagraph({
            Title = "v2.9.6",
            Content = [[May 11, 2025]]
        })
    end)

    task.spawn(function()

        Tabs.Main:AddSection("Basic Settings")
        Tabs.Main:AddButton(
            {
                Title = "Get Gamepass",
                Description = "",
                Callback = function()
                    local leaderstats = player:FindFirstChild("leaderstats")
                    if leaderstats then
                        local passes = leaderstats:FindFirstChild("Passes")
                        if passes then
                            passes:SetAttribute("AutoAttack", true)
                            passes:SetAttribute("AutoClicker", true)
                            passes:SetAttribute("DoubleCoins", true)
                            passes:SetAttribute("DoubleExp", true)
                            passes:SetAttribute("DoubleGems", true)
                            passes:SetAttribute("ExtraEquip", true)
                            passes:SetAttribute("ExtraRise", true)
                            passes:SetAttribute("InstaDestroy", true)
                            passes:SetAttribute("InstaArise", true)
                            passes:SetAttribute("DoubleDrops", true)
                            passes:SetAttribute("MoreStorage", true)
                            passes:SetAttribute("MoreStorage2", true)
                            Fluent:Notify(
                                {
                                    Title = "Perfectus",
                                    Content = "Gamepass received successfully.",
                                    Duration = 3
                                }
                            )
                        else
                            warn("Damn")
                        end
                    else
                        warn("leaderstats folder not found")
                    end
                end
            }
        )

        Tabs.Main:AddButton(
            {
                Title = "Redeem Codes",
                Description = "",
                Callback = function()
                    local remote = game:GetService("ReplicatedStorage"):WaitForChild("BridgeNet2"):WaitForChild("dataRemoteEvent")
                    local codes = {"QUESTS", "ALIENS", "1MLIKES", "WINTERRAID", "EASTER", "GZIRU"}
                    for _, code in ipairs(codes) do
                        local args = {
                            [1] = {
                                [1] = {
                                    ["Event"] = "UseCode",
                                    ["Code"] = code
                                },
                                [2] = orosbucocugu
                            }
                        }
                        remote:FireServer(unpack(args))
                        task.wait(0.3)
                    end
                end
            }
        )

        Tabs.Main:AddButton(
            {
                Title = "Boost Shadows Speed",
                Description = "",
                Callback = function()
                    game:GetService("Players").LocalPlayer.leaderstats.PlayerStats:SetAttribute("ShadowRange", 199)
                    task.wait(0.1)
                	game:GetService("Players").LocalPlayer.leaderstats.PlayerStats:SetAttribute("ShadowSpeed", 199)    
                end
            }
        )
        
        Tabs.Main:AddSection("Farm Settings")
            Tabs.Main:AddDropdown(
            "MovementMethod",
            {
                Title = "Method",
                Values = {"Tween", "Teleport", "Walk"},
                Multi = false,
                Default = 2,
                Callback = function(option)
                    movementMethod = option
                end
            }
        )
        
            Tabs.Main:AddDropdown(
            "FarmType",
            {
                Title = "Farm Type",
                Values = {"Normal", "Nearest", "Highest HP", "Lowest HP"},
                Multi = false,
                Default = "Normal",
                Callback = function(option)
                    farmingStyle = option
                end
            }
        )
        
            Tabs.Main:AddDropdown(
            "MobType",
            {
                Title = "Mob Type",
                Values = MOB_TYPES,
                Multi = true,
                Default = {},
                Callback = function(Value)
                    selectedMobTypes = {}
                    for mobType, isSelected in pairs(Value) do
                        if isSelected then
                            table.insert(selectedMobTypes, mobType)
                        end
                    end
                end
            }
        )



        Tabs.Main:AddSlider(
            "MainWalkSpeed",
            {
                Title = "Walk Speed",
                Description = "",
                Default = 10,
                Min = 0.1,
                Max = 999,
                Rounding = 0.1,
            }
        ):OnChanged(function(Value)
            game:GetService("Players").LocalPlayer.leaderstats.PlayerStats:SetAttribute("PlayerSpeed", Value)
        end)
        
                Tabs.Main:AddSlider(
                    "MainTweenSpeed",
                    {
                        Title = "Tween Speed",
                        Description = "",
                        Default = mainTweenSpeed,
                        Min = 0.1,
                        Max = 3.0,
                        Rounding = 1,
                        Callback = function(Value)
                            mainTweenSpeed = Value
                        end
                    }
                )
        
            Tabs.Main:AddSlider(
            "Slider",
            {
                Title = "Farm Delay",
                Description = "",
                Default = 0.7,
                Min = 0.1,
                Max = 5,
                Rounding = 1,
                Callback = function(Value)
                    delay = Value
                end
            }
        )
        
 
        
        Tabs.Main:AddSection("Auto Farm")

        local worldToMobs = {
            ["Leveling City"] = {"Soondoo", "Gonshee", "LongIn", "Daek", "Anders", "Largalgan"},
            ["Grass Village"] = {"Snake Man", "Blossom", "Black Crow"},
            ["Brum Island"] = {"Shark Man", "Eminel", "Light Admiral"},
            ["Faceheal Town"] = {"Luryu", "Fyakuya", "Genji"},
            ["Lucky Kingdom"] = {"Sortudo", "Michille", "Wind"},
            ["Nipon City"] = {"Heaven", "Zere", "Ika"},
            ["Mori Town"] = {"Diablo", "Gosuke", "Golyne"},
            ["Dragon City"] = {"Turtle", "Green", "Sky"},
            ["XZ City"] = {"Rider", "Cyborg", "Hurricane"},
            ["Kindama City"] = {"Shrimp", "Baira", "Lomo"},
            ["Hunters City"] = {"Wuiri Brute", "Wuiri", "Chris", "Chris Brute", "Gernnart", "Gernnart Brute"}
        }

        local allWorlds = {
            "Leveling City",
            "Grass Village",
            "Brum Island", 
            "Faceheal Town",
            "Lucky Kingdom",
            "Nipon City",
            "Mori Town",
            "Dragon City",
            "XZ City",
            "Kindama City",
            "Hunters City"
        }
        

        local selectedWorld = allWorlds[1]
        local currentMobs = worldToMobs[selectedWorld] or {}
        local currentWorldName = getCurrentWorldName()

        local WorldDropdown = Tabs.Main:AddDropdown(
            "WorldDropdown",
            {
            Title = "Select World",
            Description = "Filter mobs by world",
            Values = allWorlds,
            Multi = false,
            Default = currentWorldName
            }
        )

        local MobDropdown = Tabs.Main:AddDropdown(
            "MobDropdown",
            {
                Title = "Select Mobs",
                Description = "Mobs from selected world",
                Values = currentMobs,
                Multi = true,
                Default = {}
            }
        )

        MobDropdown:OnChanged(
            function(Value)
                local selectedMobs = {}
                for mobName, isSelected in next, Value do
                    if isSelected then
                        table.insert(selectedMobs, mobName)
                    end
                end

                _G.selectedMobs = selectedMobs
                selectedMobName = #selectedMobs > 0 and selectedMobs[1] or ""
                killedNPCs = {}
            end
        )
        
WorldDropdown:OnChanged(
    function(Value)
    selectedWorld = Value
    currentMobs = worldToMobs[selectedWorld] or {}

    if MobDropdown then
        MobDropdown:SetValues(currentMobs)
    end
end)

        Tabs.Main:AddToggle(
            "FarmSelectedMob",
            {
                Title = "Farm Selected Mobs",
                Default = false,
                Callback = function(state)
                    if state and game.PlaceId ~= 87039211657390 then
                        return
                    end
                    teleportEnabled = state
                    damageEnabled = state 
                    killedNPCs = {}
                    if state then
                        task.spawn(teleportToSelectedEnemy)
                        game:GetService("Players").LocalPlayer:SetAttribute("AutoClick", true)
                    end
                end
            }
        )

        Tabs.Main:AddToggle(
            "AutoFarmAllMobs",
            {
                Title = "Auto Farm All Mobs",
                Default = false,
                Callback = function(state)
                    if state and game.PlaceId ~= 87039211657390 then
                        return
                    end
                    autoFarmV2Enabled = state
                    teleportEnabled = false
                    if state then
                        task.spawn(autoFarmV2)
                        game:GetService("Players").LocalPlayer:SetAttribute("AutoClick", true)
                    end
                end
            }
        )

        Tabs.Main:AddSection("Auto Rejoin")
        
        Tabs.Main:AddParagraph({
            Title = "Info",
            Content = "If you experience crashes during long farm sessions, you can enable this as an alternative solution. Don't forget to enable Auto Execute as well!"
        })
        
        local autoRejoinMainEnabled = false
        local autoRejoinMainThread
        
        Tabs.Main:AddToggle("AutoRejoinMain", {
            Title = "Auto Rejoin",
            Default = false,
            Callback = function(state)
                autoRejoinMainEnabled = state
                if state then
                    if autoRejoinMainThread then
                        autoRejoinMainThread:Disconnect()
                    end
                    autoRejoinMainThread = task.spawn(function()
                        while autoRejoinMainEnabled do
                            for i = 1, 900 do
                                if not autoRejoinMainEnabled then return end
                                task.wait(1)
                            end
                            if autoRejoinMainEnabled then
                                game:GetService("TeleportService"):Teleport(game.PlaceId, game.Players.LocalPlayer)
                            end
                        end
                    end)
                end
            end
        })
        
        Tabs.Main:AddSection("Auto Attack")
        local function attackNearest()
            local Player_HumanoidRootPart = LocalPlayer.Character:FindFirstChild("HumanoidRootPart")
            local nearestPlayer, nearestDistance
            for _, NPC in pairs(game.Workspace.__Main.__Enemies.Client:GetChildren()) do
                if Player_HumanoidRootPart and NPC then
                    local distance = (NPC.HumanoidRootPart.Position - Player_HumanoidRootPart.Position).Magnitude
                    if
                        distance <= maxDistance and (not nearestDistance or distance < nearestDistance) and
                            NPC.HealthBar.Main.Bar.Amount.Text ~= "0 HP"
                     then
                        nearestDistance = distance
                        nearestPlayer = NPC
                    end
                end
            end

            if nearestPlayer then
                local targetPart = nearestPlayer:FindFirstChild("HumanoidRootPart")
                if targetPart then
                    teleportPetsToTargetPart(targetPart)
                end
                sendAttackCommand(nearestPlayer.Name, false)
            end
        end
        
            Tabs.Main:AddSlider(
            "Slider",
            {
                Title = "Auto Attack Range",
                Description = "",
                Default = 30,
                Min = 0,
                Max = 120,
                Rounding = 0.1,
                Callback = function(Value)
                    maxDistance = tonumber(Value)
                end
            }
        )
        
        
        local ToggleMain1 = Tabs.Main:AddToggle("MyToggleMain1", {Title = "Auto Attack v2", Default = false})
        ToggleMain1:OnChanged(
            function()
                if Options.MyToggleMain1.Value and not userFolder:GetChildren()[1] then
                    Options.MyToggleMain1:SetValue(false)
                    Fluent:Notify(
                        {
                            Title = "Notification",
                            Content = "You don't have shadow equipped",
                            Duration = 3
                        }
                    )
                elseif Options.MyToggleMain1.Value and userFolder:GetChildren()[1] then
                    repeat
                        local total = 0
                        for _, v in pairs(PET_FOLDER) do
                            if v:GetAttribute("Target") or v:GetAttribute("Target") == "" then
                                total = total + 1
                                print(total)
                            end
                        end
                        if total == 0 then
                            print("total == ", total)
                            attackNearest()
                        else
                            total = 0
                            print("total reset")
                        end
                        task.wait(0.5)
                    until not Options.MyToggleMain1.Value
                end
            end
        )
        
        Tabs.Main:AddSection("Auto Arise, Destroy")
        
        local ToggleMain2 = Tabs.Main:AddToggle("MyToggleMain2", {Title = "Auto Arise", Default = false})
        ToggleMain2:OnChanged(
            function()
                if Options.MyToggleMain2.Value then
                    connection =
                        workspace.__Main.__Enemies.Client.DescendantAdded:Connect(
                        function(descendant)
                            if descendant:IsA("ProximityPrompt") and descendant.Name == "ArisePrompt" then
                                print("Found", descendant)
                                local num = 0
                                while descendant.Parent and Options.MyToggleMain2.Value do
                                    descendant.HoldDuration = 0
                                    fireproximityprompt(descendant)
                                    num = num + 1
                                    print(num, descendant.Parent)
                                    task.wait(ariseDestroyDelay)
                                end
                            end
                        end
                    )
                else
                    if connection then
                        connection:Disconnect()
                        connection = nil
                    end
                end
            end
        )
        
        local ToggleMain3 = Tabs.Main:AddToggle("MyToggleMain3", {Title = "Auto Destroy", Default = false})
        ToggleMain3:OnChanged(
            function()
                if Options.MyToggleMain3.Value then
                    local connection =
                        workspace.__Main.__Enemies.Client.DescendantAdded:Connect(
                        function(descendant)
                            if descendant:IsA("ProximityPrompt") and descendant.Name == "DestroyPrompt" then
                                print("Found", descendant)
                                local num = 0
                                while descendant.Parent and Options.MyToggleMain3.Value do
                                    descendant.HoldDuration = 0
                                    fireproximityprompt(descendant)
                                    num = num + 1
                                    print(num, descendant.Parent)
                                    task.wait(ariseDestroyDelay)
                                end
                            end
                        end
                    )
                else
                    if connection then
                        connection:Disconnect()
                        connection = nil
                    end
                end
            end
        )

        Tabs.Main:AddSlider(
            "AriseDestroyDelay",
            {
                Title = "Arise/Destroy Delay",
                Description = "",
                Default = 0.1,
                Min = 0.01,
                Max = 3,
                Rounding = 2,
                Callback = function(Value)
                    ariseDestroyDelay = Value
                end
            }
        )

        Tabs.Main:AddSection("Filtered Auto Arise/Destroy")

        local allMobs = {}
        for _, mobsList in pairs(worldToMobs) do
            for _, mobName in ipairs(mobsList) do
                if not table.find(allMobs, mobName) then
                    table.insert(allMobs, mobName)
                end
            end
        end

        table.sort(allMobs)

        local ariseSelectedMobTypes = {}
        local destroySelectedMobTypes = {}
        local ariseSelectedMobs = {}
        local destroySelectedMobs = {}

        local AriseTypeDropdown = Tabs.Main:AddDropdown(
            "AriseTypeDropdown",
            {
                Title = "Arise - Mob Types",
                Description = "",
                Values = {"Normal", "Big"},
                Multi = true,
                Default = {}
            }
        )

        AriseTypeDropdown:OnChanged(
            function(Value)
                ariseSelectedMobTypes = {}
                for mobType, isSelected in pairs(Value) do
                    if isSelected then
                        table.insert(ariseSelectedMobTypes, mobType)
                    end
                end
            end
        )

        local DestroyTypeDropdown = Tabs.Main:AddDropdown(
            "DestroyTypeDropdown",
            {
                Title = "Destroy - Mob Types",
                Description = "",
                Values = {"Normal", "Big"},
                Multi = true,
                Default = {}
            }
        )

        DestroyTypeDropdown:OnChanged(
            function(Value)
                destroySelectedMobTypes = {}
                for mobType, isSelected in pairs(Value) do
                    if isSelected then
                        table.insert(destroySelectedMobTypes, mobType)
                    end
                end
            end
        )

        local AriseMobDropdown = Tabs.Main:AddDropdown(
            "AriseMobDropdown",
            {
                Title = "Arise - Specific Mobs",
                Description = "",
                Values = allMobs,
                Multi = true,
                Default = {}
            }
        )

        AriseMobDropdown:OnChanged(
            function(Value)
                ariseSelectedMobs = {}
                for mobName, isSelected in pairs(Value) do
                    if isSelected then
                        table.insert(ariseSelectedMobs, mobName)
                    end
                end
            end
        )

        local DestroyMobDropdown = Tabs.Main:AddDropdown(
            "DestroyMobDropdown",
            {
                Title = "Destroy - Specific Mobs",
                Description = "",
                Values = allMobs,
                Multi = true,
                Default = {}
            }
        )

        DestroyMobDropdown:OnChanged(
            function(Value)
                destroySelectedMobs = {}
                for mobName, isSelected in pairs(Value) do
                    if isSelected then
                        table.insert(destroySelectedMobs, mobName)
                    end
                end
            end
        )

        local function isMatchingAriseFilteredMob(enemy)
            local typeFilterApplied = #ariseSelectedMobTypes > 0
            local mobFilterApplied = #ariseSelectedMobs > 0

            if not typeFilterApplied and not mobFilterApplied then
                return false
            end

            if typeFilterApplied then
                local mobType = getMobType(enemy)
                if not table.find(ariseSelectedMobTypes, mobType) then
                    return false
                end
            end

            if mobFilterApplied then
                local healthBar = enemy:FindFirstChild("HealthBar")
                if healthBar and healthBar:FindFirstChild("Main") and healthBar.Main:FindFirstChild("Title") then
                    local mobName = healthBar.Main.Title.Text
                    if not table.find(ariseSelectedMobs, mobName) then
                        return false
                    end
                else
                    return false
                end
            end

            return true
        end

        local function isMatchingDestroyFilteredMob(enemy)
            local typeFilterApplied = #destroySelectedMobTypes > 0
            local mobFilterApplied = #destroySelectedMobs > 0

            if not typeFilterApplied and not mobFilterApplied then
                return false
            end

            if typeFilterApplied then
                local mobType = getMobType(enemy)
                if not table.find(destroySelectedMobTypes, mobType) then
                    return false
                end
            end

            if mobFilterApplied then
                local healthBar = enemy:FindFirstChild("HealthBar")
                if healthBar and healthBar:FindFirstChild("Main") and healthBar.Main:FindFirstChild("Title") then
                    local mobName = healthBar.Main.Title.Text
                    if not table.find(destroySelectedMobs, mobName) then
                        return false
                    end
                else
                    return false
                end
            end

            return true
        end

        local filteredActionsConnection
        local FilteredActionsToggle = Tabs.Main:AddToggle(
            "FilteredActionsToggle", 
            {
                Title = "Activate Filtered Actions", 
                Default = false
            }
        )

        FilteredActionsToggle:OnChanged(function(state)
            if state then
                filteredActionsConnection = workspace.__Main.__Enemies.Client.DescendantAdded:Connect(
                    function(descendant)
                        if descendant:IsA("ProximityPrompt") then
                            local enemy = descendant:FindFirstAncestorOfClass("Model")
                            if not enemy then return end

                            local processId = game:GetService("HttpService"):GenerateGUID(false)
                            local isProcessActive = true

                            local function checkToggleState()
                                return Options.FilteredActionsToggle.Value and isProcessActive
                            end
                            
                            if descendant.Name == "ArisePrompt" and isMatchingAriseFilteredMob(enemy) then
                                task.spawn(function()
                                    while descendant.Parent and checkToggleState() do
                                        descendant.HoldDuration = 0
                                        fireproximityprompt(descendant)
                                        task.wait(ariseDestroyDelay)
                                    end
                                end)
                            elseif descendant.Name == "DestroyPrompt" and isMatchingDestroyFilteredMob(enemy) then
                                task.spawn(function()
                                    while descendant.Parent and checkToggleState() do
                                        descendant.HoldDuration = 0
                                        fireproximityprompt(descendant)
                                        task.wait(ariseDestroyDelay)
                                    end
                                end)
                            end
                        end
                    end
                )
            else
                if filteredActionsConnection then
                    filteredActionsConnection:Disconnect()
                    filteredActionsConnection = nil
                end
            end
        end)

        Tabs.Main:AddSection("Guild")

        local donateNumber = 0

        Tabs.Main:AddInput(
            "Donate",
            {
                Title = "How much donate?",
                Description = "",
                Default = "",
                Placeholder = "0",
                Numeric = true,
                Finished = true,
                Callback = function(value)
                donateNumber = value
                end
            })

            Tabs.Main:AddToggle(
                "DonateButton",
                {
                    Title = "Donate",
                    Default = false,
                    Callback = function(state)
                    startdonate = state
                        if startdonate then
                            while startdonate do
                            local args = {
                                [1] = {
                                    [1] = {
                                        ["Action"] = "Donate",
                                        ["Event"] = "GuildAction",
                                        ["Amount"] = donateNumber
                                    },
                                    [2] = orosbucocugu
                                }
                            }
                            
                            game:GetService("ReplicatedStorage").BridgeNet2.dataRemoteEvent:FireServer(unpack(args))
                            task.wait(0.5)
                            end
                        end
                    end
                })

                
                Tabs.Main:AddSection("Quest")
                Tabs.Main:AddToggle(
                    "AutoQuest",
                    {
                        Title = "Auto Claim Daily Quest",
                        Default = false,
                        Callback = function(state)
                            autoQuestEnabled = state
                            if state then
                                task.spawn(function()
                                    while autoQuestEnabled do
                                        local args = {[1] = {[1] = {["Id"] = "DailyTime",["Type"] = "Daily",["Event"] = "ClaimQuest"},[2] = "\11"}}game:GetService("ReplicatedStorage").BridgeNet2.dataRemoteEvent:FireServer(unpack(args))
                                        task.wait(0.1)
                                        local args = {[1] = {[1] = {["Id"] = "DailyBrute",["Type"] = "Daily",["Event"] = "ClaimQuest"},[2] = "\11"}}game:GetService("ReplicatedStorage").BridgeNet2.dataRemoteEvent:FireServer(unpack(args))
                                        task.wait(0.1)
                                        local args = {[1] = {[1] = {["Id"] = "DailyDungeon",["Type"] = "Daily",["Event"] = "ClaimQuest"},[2] = "\11"}}game:GetService("ReplicatedStorage").BridgeNet2.dataRemoteEvent:FireServer(unpack(args))
                                        task.wait(0.1)
                                        local args = {[1] = {[1] = {["Id"] = "DailyEnemy",["Type"] = "Daily",["Event"] = "ClaimQuest"},[2] = "\11"}}game:GetService("ReplicatedStorage").BridgeNet2.dataRemoteEvent:FireServer(unpack(args))
                                        task.wait(0.1)
                                    end
                                end)
                            end
                        end
                    })
                    
                    Tabs.Main:AddToggle(
                        "AutoQuest2",
                        {
                            Title = "Auto Claim Weekly Quest",
                            Default = false,
                            Callback = function(state)
                                autoQuestEnabled2 = state
                                if state then
                                    task.spawn(function()
                                        while autoQuestEnabled2 do
                                            local args = {[1] = {[1] = {["Id"] = "WeeklyArise",["Type"] = "Weekly",["Event"] = "ClaimQuest"},[2] = "\11"}}game:GetService("ReplicatedStorage").BridgeNet2.dataRemoteEvent:FireServer(unpack(args))
                                            task.wait(0.1)
                                            local args = {[1] = {[1] = {["Id"] = "WeeklyBrute",["Type"] = "Weekly",["Event"] = "ClaimQuest"},[2] = "\11"}}game:GetService("ReplicatedStorage").BridgeNet2.dataRemoteEvent:FireServer(unpack(args))
                                            task.wait(0.1)
                                            local args = {[1] = {[1] = {["Id"] = "WeeklyDungeon",["Type"] = "Weekly",["Event"] = "ClaimQuest"},[2] = "\11"}}game:GetService("ReplicatedStorage").BridgeNet2.dataRemoteEvent:FireServer(unpack(args))
                                            task.wait(0.1)
                                            local args = {[1] = {[1] = {["Id"] = "WeeklyEnemy",["Type"] = "Weekly",["Event"] = "ClaimQuest"},[2] = "\11"}}game:GetService("ReplicatedStorage").BridgeNet2.dataRemoteEvent:FireServer(unpack(args))
                                            task.wait(0.1)
                                        end
                                    end)
                                end
                            end
                        })

                Tabs.Winter:AddSection("Winter Farm")

                local function teleportToWinter()
                    if not (player.Character and player.Character:FindFirstChild("HumanoidRootPart")) then
                        return false
                    end
                    anticheat()
                    player.Character.HumanoidRootPart.CFrame = WINTER_CFRAME
                    task.wait(0.5)
                    player.Character.HumanoidRootPart.CFrame = WINTER_CFRAME
                    task.wait(0.5)
                    local spawn = workspace:FindFirstChild("__Main")
                        and workspace.__Main:FindFirstChild("__World")
                        and workspace.__Main.__World:FindFirstChild("WinterIsland")
                        and workspace.__Main.__World.WinterIsland:FindFirstChild("Buildings")
                        and workspace.__Main.__World.WinterIsland.Buildings:FindFirstChild("Model")
                        and workspace.__Main.__World.WinterIsland.Buildings.Model:FindFirstChild("DoubleDungeonSpawn")
                        and workspace.__Main.__World.WinterIsland.Buildings.Model.DoubleDungeonSpawn:FindFirstChild("DoubleDungeonSpawn")
                    return spawn ~= nil
                end
                
                local function savePosition()
                    if player.Character and player.Character:FindFirstChild("HumanoidRootPart") then
                        savedWinterPosition = player.Character.HumanoidRootPart.CFrame
                    end
                end
                
                local function returnToSaved()
                    if not savedWinterPosition then
                        return false
                    end
                    if player.Character and player.Character:FindFirstChild("HumanoidRootPart") then
                        anticheat()
                        player.Character.HumanoidRootPart.CFrame = savedWinterPosition
                        return true
                    end
                    return false
                end
        
                local function anyMobsExist()
                    if not enemiesFolder then return false end
                    
                    for _, enemy in pairs(enemiesFolder:GetChildren()) do
                        if enemy:IsA("Model") and enemy:FindFirstChild("HumanoidRootPart") and not isEnemyDead(enemy) then
                            return true
                        end
                    end
                    return false
                end
                
                local function farmWinterIsland()
                    local target
                    for _, e in ipairs(enemiesFolder:GetChildren()) do
                        if e:IsA("Model") and e:FindFirstChild("HumanoidRootPart") and not isEnemyDead(e) then
                            local shouldIgnore = false
                            if e:FindFirstChild("HealthBar") and e.HealthBar:FindFirstChild("Main") and e.HealthBar.Main:FindFirstChild("Title") then
                                local mobName = e.HealthBar.Main.Title.Text
                                if table.find(ignoredWinterMobs, mobName) then
                                    shouldIgnore = true
                                end
                            end
                            
                            if not shouldIgnore then
                                target = e
                                break
                            end
                        end
                    end
                    if not target then return false end
                
                    local hrp = player.Character.HumanoidRootPart
                    if winterFarmMethod == "Teleport" then
                        anticheat()
                        hrp.CFrame = target.HumanoidRootPart.CFrame * CFrame.new(0,2,6)
                
                    elseif winterFarmMethod == "Tween" then
                        local ti = TweenInfo.new(winterTweenSpeed, Enum.EasingStyle.Linear, Enum.EasingDirection.Out)
                        local tw = TweenService:Create(hrp, ti, {CFrame = target.HumanoidRootPart.CFrame * CFrame.new(0,2,6)})
                        tw:Play(); tw.Completed:Wait()
                
                    elseif winterFarmMethod == "Walk" then
                        enableNoclip()
                        local hum = hrp.Parent:FindFirstChildOfClass("Humanoid")
                        if hum then
                            hum.WalkSpeed = winterWalkSpeed
                            hum:MoveTo((target.HumanoidRootPart.CFrame * CFrame.new(0,0,4)).Position)
                            local reached=false; local conn
                            conn = hum.MoveToFinished:Connect(function(s) reached=s end)
                            local t0 = tick()
                            while not reached and tick()-t0<3 do task.wait(0.05) end
                            conn:Disconnect()
                        end
                    end
                
                    task.wait(0.05)
                    sendAttackCommand(target.Name, true)
                    while target.Parent and not isEnemyDead(target) do task.wait(0.1) end
                    task.wait(winterFarmDelay)
                    return true
                end
                
                local function hasAliveEnemies()
                    if not enemiesFolder then return false end
                    
                    for _, enemy in pairs(enemiesFolder:GetChildren()) do
                        if enemy:IsA("Model") and enemy:FindFirstChild("HumanoidRootPart") and not isEnemyDead(enemy) then
                            local shouldIgnore = false
                            if enemy:FindFirstChild("HealthBar") and enemy.HealthBar:FindFirstChild("Main") and enemy.HealthBar.Main:FindFirstChild("Title") then
                                local mobName = enemy.HealthBar.Main.Title.Text
                                if table.find(ignoredWinterMobs, mobName) then
                                    shouldIgnore = true
                                end
                            end
                            
                            if not shouldIgnore then
                                return true
                            end
                        end
                    end
                    return false
                end
                
                local function bossExists()
                    if not enemiesFolder then return false end
                    
                    for _, enemy in pairs(enemiesFolder:GetChildren()) do
                        if enemy:IsA("Model") and enemy:FindFirstChild("HumanoidRootPart") and 
                           enemy:FindFirstChild("HealthBar") and enemy.HealthBar:FindFirstChild("Main") and 
                           enemy.HealthBar.Main:FindFirstChild("Title") and
                           enemy.HealthBar.Main.Title.Text == winterEndBoss then
                            return true, enemy, isEnemyDead(enemy)
                        end
                    end
                    return false, nil, false
                end
                
                local function serverHopWinter()
                    if not winterServerHopEnabled then
                        return
                    end
                    
                    print("Starting server hop process...")
                    local TeleportService = game:GetService("TeleportService")
                    local HttpService = game:GetService("HttpService")
                    local servers = {}
                    
                    local function fetchServers(cursor)
                        local url = "https://games.roblox.com/v1/games/" .. game.PlaceId .. "/servers/Public?sortOrder=Asc&limit=100" 
                        if cursor then
                            url = url .. "&cursor=" .. cursor
                        end
                        
                        local success, result = pcall(function()
                            return HttpService:JSONDecode(game:HttpGet(url))
                        end)
                        
                        if success and result and result.data then
                            for _, server in pairs(result.data) do
                                if server and server.playing and server.id ~= game.JobId then
                                    table.insert(servers, server)
                                end
                            end
                            
                            if result.nextPageCursor then
                                fetchServers(result.nextPageCursor)
                            end
                        end
                    end
                    
                    pcall(fetchServers)
                    
                    if #servers == 0 then
                        Fluent:Notify({
                            Title = "Winter Raid",
                            Content = "No servers found for hopping",
                            Duration = 3
                        })
                        return
                    end
                    Fluent:Notify({
                        Title = "Winter Raid",
                        Content = "Found " .. #servers .. " servers for hopping",
                        Duration = 3
                    })
                    
                    if winterServerPreference == "Low Player Server" then
                        table.sort(servers, function(a, b)
                            return a.playing < b.playing
                        end)
                    else
                        table.sort(servers, function(a, b)
                            return a.playing > b.playing
                        end)
                    end
                    
                    for _, server in pairs(servers) do
                        if server and server.id then
                            print("Attempting to teleport to server: " .. server.id .. " with " .. server.playing .. " players")
                            TeleportService:TeleportToPlaceInstance(game.PlaceId, server.id, player)
                            task.wait(2)
                        end
                    end
                    Fluent:Notify({
                        Title = "Winter Raid",
                        Content = "Server hop failed or completed, returning to saved position",
                        Duration = 3
                    })
                    returnToSaved()
                end
                
                Tabs.Winter:AddToggle("AutoWinterFarm", {
                    Title = "Auto Winter Farm",
                    Default = false,
                    Callback = function(state)
                        winterFarmEnabled = state
        
                        if state and game.PlaceId ~= 87039211657390 then
                            return
                        end
                
                        task.spawn(function()
                            while winterFarmEnabled do
                                if player.Character and player.Character:FindFirstChild("HumanoidRootPart") then
                                    anticheat()
                                    player.Character.HumanoidRootPart.CFrame = WINTER_CFRAME
                                    task.wait(0.5)
                                    player.Character.HumanoidRootPart.CFrame = WINTER_CFRAME2
                                    task.wait(1)
                                end
                                
                                if anyMobsExist() then
                                    local tempFarmingStyle = farmingStyle
                                    local tempMovementMethod = movementMethod
                                    local tempTargetedEnemies = targetedEnemies
                                    
                                    local farming = true
                                    while winterFarmEnabled and farming do
                                        local bossFound, bossEnemy, bossDefeated = bossExists()

                                        if bossFound and not bossDefeated then
                                            Fluent:Notify({
                                                Title = "Winter Raid",
                                                Content = "Boss found, attacking...",
                                                Duration = 3
                                            })
                                            if player.Character and player.Character:FindFirstChild("HumanoidRootPart") then
                                                local hrp = player.Character.HumanoidRootPart
                                                anticheat()
                                                
                                                if winterFarmMethod == "Teleport" then
                                                    hrp.CFrame = bossEnemy.HumanoidRootPart.CFrame * CFrame.new(0,2,6)
                                                elseif winterFarmMethod == "Tween" then
                                                    local ti = TweenInfo.new(winterTweenSpeed, Enum.EasingStyle.Linear, Enum.EasingDirection.Out)
                                                    local tw = TweenService:Create(hrp, ti, {CFrame = bossEnemy.HumanoidRootPart.CFrame * CFrame.new(0,2,6)})
                                                    tw:Play(); tw.Completed:Wait()
                                                elseif winterFarmMethod == "Walk" then
                                                    enableNoclip()
                                                    local hum = hrp.Parent:FindFirstChildOfClass("Humanoid")
                                                    if hum then
                                                        hum.WalkSpeed = winterWalkSpeed
                                                        hum:MoveTo((bossEnemy.HumanoidRootPart.CFrame * CFrame.new(0,0,4)).Position)
                                                        local reached = false; local conn
                                                        conn = hum.MoveToFinished:Connect(function(s) reached = s end)
                                                        local t0 = tick()
                                                        while not reached and tick()-t0<3 do task.wait(0.05) end
                                                        conn:Disconnect()
                                                    end
                                                end
                                                
                                                task.wait(0.05)
                                                sendAttackCommand(bossEnemy.Name, true)
                                                while bossEnemy.Parent and not isEnemyDead(bossEnemy) do task.wait(0.1) end

                                                task.wait(2)
                                                farming = false
                                                
                                                if winterServerHopEnabled then
                                                    Fluent:Notify({
                                                        Title = "Winter Raid",
                                                        Content = "Boss defeated, server hopping...",
                                                        Duration = 3
                                                    })
                                                    task.wait(1)
                                                    serverHopWinter()
                                                elseif autoReturnEnabled then
                                                    returnToSaved()
                                                end
                                                break
                                            end
                                        elseif bossFound and bossDefeated then
                                            print("Boss already defeated")
                                            farming = false
                                            if winterServerHopEnabled then
                                                serverHopWinter()
                                            elseif autoReturnEnabled then
                                                returnToSaved()
                                            end
                                            break
                                        elseif hasAliveEnemies() then
                                            local farmedSomething = farmWinterIsland()
                                            if not farmedSomething then
                                                task.wait(1)
                                            end
                                        else
                                            print("Waiting for boss or non-ignored enemies...")

                                            if player.Character and player.Character:FindFirstChild("HumanoidRootPart") then
                                                anticheat()
                                                player.Character.HumanoidRootPart.CFrame = WINTER_CFRAME2
                                            end

                                            if not anyMobsExist() then
                                                print("No more enemies found, raid may be over")
                                                farming = false
                                                
                                                if autoReturnEnabled then
                                                    returnToSaved()
                                                end
                                                break
                                            end
                                            
                                            task.wait(1)
                                        end
                                    end

                                    farmingStyle = tempFarmingStyle
                                    movementMethod = tempMovementMethod
                                    targetedEnemies = tempTargetedEnemies
                                    
                                else
                                    local t = os.date("*t")
                                    local waitMinutes = t.min < 10 and (10 - t.min) or (60 - t.min + 10)
                                    local secs = waitMinutes * 60 - t.sec

                                    local returnSuccess = returnToSaved()
                                    if returnSuccess then
                                        isWinterActive = false
                                    end
                                    
                                    Fluent:Notify({
                                        Title = "Winter Raid",
                                        Content = "Waiting " .. secs .. " seconds for next Winter raid",
                                        Duration = 3
                                    })
                                    
                                    task.wait(secs)                                    
                                    
                                    if winterFarmEnabled then
                                        isWinterActive = true
                                    end
                                end
                            end
                        end)
                    end
                })
                
                local IgnoreWinterMobsDropdown = Tabs.Winter:AddDropdown("IgnoreWinterMobs", {
                    Title = "Ignore Mobs",
                    Values = {"Metal", "Snow Monarch", "Elf Soldier", "Laruda", "Winter Bear", "High Frost"},
                    Multi = true,
                    Default = {}
                })
        
                Tabs.Winter:AddDropdown("WinterEndBoss", {
                    Title = "End Boss Selection",
                    Values = {"Snow Monarch", "Laruda"},
                    Default = winterEndBoss,
                    Callback = function(v)
                        winterEndBoss = v
                    end
                })
                
                IgnoreWinterMobsDropdown:OnChanged(function(Value)
                    ignoredWinterMobs = {}
                    for Value, State in next, Value do
                        if State then
                            table.insert(ignoredWinterMobs, Value)
                        end
                    end
                end)
                
                Tabs.Winter:AddDropdown("WinterMethod", {
                    Title="Farm Method", Values={"Teleport","Tween","Walk"},
                    Default=winterFarmMethod,
                    Callback=function(v) 
                        winterFarmMethod = v
                    end
                })
                
                Tabs.Winter:AddSlider("WinterTweenSpeed", {
                    Title       = "Tween Speed",
                    Description = "",
                    Default     = winterTweenSpeed,
                    Min         = 0.3,
                    Max         = 3.0,
                    Rounding    = 1,
                    Callback    = function(v)
                        winterTweenSpeed = v
                    end
                })
                
                Tabs.Winter:AddSlider("WinterDelay", {
                    Title       = "Farm Delay",
                    Description = "",
                    Default     = winterFarmDelay,
                    Min         = 1,
                    Max         = 15,
                    Rounding    = 0.1,
                    Callback    = function(v)
                        winterFarmDelay = v
                    end
                })

                Tabs.Winter:AddSection("Position")
                
                Tabs.Winter:AddButton({
                    Title = "Save Position",
                    Description = "Save current position for return",
                    Callback = savePosition
                })
                
                Tabs.Winter:AddToggle("AutoReturn", {
                    Title = "Auto Return After Farming",
                    Default = false,
                    Callback = function(state)
                        autoReturnEnabled = state
                    end
                })
                
                Tabs.Winter:AddSection("Winter Server Hop")
                
                Tabs.Winter:AddDropdown("WinterServerPreference", {
                    Title = "Server Player Count",
                    Values = {"Low Player Server", "High Player Server"},
                    Default = winterServerPreference,
                    Callback = function(v)
                        winterServerPreference = v
                    end
                })
        
                Tabs.Winter:AddToggle("WinterServerHop", {
                    Title = "Auto Server Hop When Raid Ends",
                    Default = winterServerHopEnabled,
                    Callback = function(state)
                        winterServerHopEnabled = state
                    end
                })
                

Tabs.Rank:AddSection("Auto Rank")

Tabs.Rank:AddDropdown(
    "AutoRankFarmMethod",
    {
        Title = "Farm Method",
        Values = {"Teleport", "Tween"},
        Multi = false,
        Default = "Teleport",
        Callback = function(Value)
            _G.autoRankFarmMethod = Value
        end
    }
)

Tabs.Rank:AddSlider(
    "AutoRankDelay",
    {
        Title = "Auto Rank Delay",
        Description = "",
        Default = 0.7,
        Min = 0.01,
        Max = 2,
        Rounding = 1,
        Callback = function(Value)
            _G.autoRankDelay = Value
        end
    }
)

Tabs.Rank:AddSlider(
    "AutoRankTweenSpeed",
    {
        Title = "Tween Speed",
        Description = "",
        Default = mainTweenSpeed,
        Min = 0.1,
        Max = 3.0,
        Rounding = 1,
        Callback = function(Value)
            _G.autoRankTweenSpeed = Value
        end
    }
)

Tabs.Rank:AddParagraph(
    {
        Title = "Current Rank",
        Content = "Rank: " .. game:GetService("Players").LocalPlayer.leaderstats.Rank.Value
    }
)

Tabs.Rank:AddToggle(
    "AutoRankToggle",
    {
        Title = "Auto Rank",
        Default = false,
        Callback = function(state)
            autoRankEnabled = state
            if state then
                game:GetService("Players").LocalPlayer:SetAttribute("AutoClick", true)

                task.spawn(
                    function()
                        if game.PlaceId ~= 128336380114944 and not workspace.__Main:FindFirstChild("Room_1") then
                            task.wait(3)
                            local args = {
                                [1] = {
                                    [1] = {
                                        ["Action"] = "TestEnter",
                                        ["Event"] = "DungeonAction"
                                    },
                                    [2] = orosbucocugu
                                }
                            }
                            remote:FireServer(unpack(args))
                            task.wait(1)
                        end
                        targetedEnemies = {}

                        while autoRankEnabled do
                            if castleFarmEnabled then
                                break
                            end

                            local target = getAnyEnemy()
                            if target and target.Parent then
                                anticheat()
                                local enemyPos = target.HumanoidRootPart.Position
                                local enemyLook = target.HumanoidRootPart.CFrame.LookVector
                                local teleportPos = enemyPos - (enemyLook * 5)
                                local targetCFrame = CFrame.new(teleportPos, enemyPos)

                                local farmMethod = _G.autoRankFarmMethod or "Teleport"
                                local farmDelay = _G.autoRankDelay or 0.7

                                if farmMethod == "Tween" then
                                    local tweenInfo = TweenInfo.new(mainTweenSpeed, Enum.EasingStyle.Linear, Enum.EasingDirection.Out)
                                    local tween = TweenService:Create(hrp, tweenInfo, {CFrame = targetCFrame})
                                    tween:Play()
                                    tween.Completed:Wait()
                                else
                                    hrp.CFrame = targetCFrame
                                end

                                task.wait(0.05)
                                sendAttackCommand(target.Name, true)
                                task.wait(0.05)
                                
                                while target.Parent and not isEnemyDead(target) do
                                    task.wait(0.1)
                                end
                                targetedEnemies[target.Name] = true

                                if farmDelay and farmDelay > 0 then
                                    task.wait(farmDelay)
                                end
                            else
                                local serverFolder = workspace.__Main.__Enemies.Server
                                if serverFolder and #serverFolder:GetChildren() > 0 then
                                    local randomIndex = math.random(1, #serverFolder:GetChildren())
                                    local serverPart = serverFolder:GetChildren()[randomIndex]

                                    if serverPart then
                                        anticheat()
                                        hrp.CFrame = serverPart.CFrame
                                        sendAttackCommand(serverPart.Name, true)
                                        task.wait(0.6)
                                    else
                                        task.wait(0.6)
                                    end
                                else
                                    task.wait(0.6)
                                end
                            end
                            task.wait(0.1)
                        end
                    end
                )
            end
        end
    }
)

        Tabs.dungeon:AddSection("Auto Dungeon Search")
        
            Tabs.dungeon:AddDropdown(
            "WorldSelection",
            {
                Title = "Select Worlds",
                Values = {
                    "Leveling City",
                    "Grass Village",
                    "Brum Island",
                    "Faceheal Town",
                    "Lucky Kingdom",
                    "Nipon City",
                    "Mori Town",
                    "Dragon Ball",
                    "One Punch",
                    "Kindama City",
                    "Hunters City"
                },
                Multi = true,
                Default = {},
                Callback = function(Value)
                    local selected = {}
                    for worldName, isSelected in pairs(Value) do
                        if isSelected then
                            table.insert(selected, worldName)
                        end
                    end
                    selectedWorlds = selected
                end
            }
        )
        
            Tabs.dungeon:AddDropdown(
            "RankSelection",
            {
                Title = "Select Ranks",
                Values = {"E", "D", "C", "B", "A", "S", "SS"},
                Multi = true,
                Default = {},
                Callback = function(Value)
                    local selected = {}
                    for rank, isSelected in pairs(Value) do
                        if isSelected then
                            table.insert(selected, rank)
                        end
                    end
                    selectedRanks = selected
                end
            }
        )
        
            Tabs.dungeon:AddDropdown(
            "DungeonTypeDropdown",
            {
                Title = "Dungeon Type",
                Values = {"Normal Dungeon", "Red Dungeon"},
                Multi = true,
                Default = {},
                Callback = function(Value)
                    local selected = {}
                    for dungeonType, isSelected in pairs(Value) do
                        if isSelected then
                            table.insert(selected, dungeonType)
                        end
                    end
                    selectedDungeonTypes = selected
                end
            }
        )

        Tabs.dungeon:AddButton({
            Title = "Select All",
            Description = "Select all options in World, Rank and Dungeon Type dropdowns",
            Callback = function()
                local allWorlds = {}
                for _, world in ipairs({
                    "Leveling City",
                    "Grass Village",
                    "Brum Island",
                    "Faceheal Town",
                    "Lucky Kingdom",
                    "Nipon City",
                    "Mori Town",
                    "Dragon Ball",
                    "One Punch",
                    "Kindama City",
                    "Hunters City"
                }) do
                    allWorlds[world] = true
                end
                Options.WorldSelection:SetValue(allWorlds)

                local allRanks = {}
                for _, rank in ipairs({"E", "D", "C", "B", "A", "S", "SS"}) do
                    allRanks[rank] = true
                end
                Options.RankSelection:SetValue(allRanks)

                local allDungeonTypes = {}
                for _, dungeonType in ipairs({"Normal Dungeon", "Red Dungeon"}) do
                    allDungeonTypes[dungeonType] = true
                end
                Options.DungeonTypeDropdown:SetValue(allDungeonTypes)
                
                Fluent:Notify({
                    Title = "Selection Complete",
                    Content = "All options have been selected in all dropdowns",
                    Duration = 3
                })
            end
        })
        
            Tabs.dungeon:AddDropdown(
            "DungeonSearchMethod",
            {
                Title = "Dungeon Search Method",
                Values = {"Teleport"},
                Multi = false,
                Default = "Teleport",
                Callback = function(value)
                end
            }
        )
        
        Tabs.dungeon:AddToggle(
            "AutoSearchDungeon",
            {
                Title = "Auto Search Dungeon",
                Default = false,
                Callback = function(state)
                    teleportingEnabled = state
                    if state then
                        if game.PlaceId ~= 87039211657390 then
                            Fluent:Notify(
                                {
                                    Title = "Warning",
                                    Content = "Dungeon search is only available in the correct place.",
                                    Duration = 5
                                }
                            )
                            teleportingEnabled = false
                            return
                        end
        
                        local selectedMethod = Options.DungeonSearchMethod.Value
                        task.spawn(
                            function()
                                searchDungeon(selectedMethod)
                            end
                        )
                    end
                end
            }
        )
        
        Tabs.dungeon:AddToggle(
            "AutoBuyTicket",
            {
                Title = "Auto Buy Ticket (Gems)",
                Default = false,
                Callback = function(state)
                    autoBuyTicketEnabled = state
                end
            }
        )
        
        Tabs.dungeon:AddSection("Dungeon Farm")

         Tabs.dungeon:AddDropdown(
            "DungeonFarmMethod",
            {
                Title = "Farm Method",
                Values = {"Teleport", "Tween"},
                Multi = false,
                Default = "Teleport",
                Callback = function(Value)
                    dungeonFarmMethod = Value
                end
            }
        )
        
         Tabs.dungeon:AddSlider(
            "DungeonTweenSpeed",
            {
                Title = "Tween Speed",
                Description = "",
                Default = dungeonTweenSpeed,
                Min = 0.1,
                Max = 3.0,
                Rounding = 1,
                Callback = function(Value)
                    dungeonTweenSpeed = Value
                end
            }
        )
        
        Tabs.dungeon:AddToggle("TeleportMobs", {
            Title = "Auto Farm Dungeon",
            Default = false,
            Callback = function(state)
                if state and isInCastle() then
                    Fluent:Notify({
                        Title = "Warning",
                        Content = "You cannot start Dungeon Farm while in Castle!",
                        Duration = 4
                    })
                    return
                end
                teleportEnabled = state
                if state then
                    task.spawn(teleportDungeon)
                    game:GetService("Players").LocalPlayer:SetAttribute("AutoClick", true)
                else
                    dungeonkill = {}
                end
            end
        })
        
        DungeonDelayDefault = 0.7
        
        Tabs.dungeon:AddSlider(
            "DungeonDelay",
            {
                Title = "Dungeon Farm Delay",
                Description = "",
                Default = DungeonDelayDefault,
                Min = 0.1,
                Max = 2,
                Rounding = 1,
                Callback = function(Value)
                    DungeonDelay = Value
                end
            }
        )

        Tabs.dungeon:AddSection("Dungeon Boss Room")

        Tabs.dungeon:AddSlider(
            "DungeonDelay2",
            {
                Title = "Dungeon Boss Wait Delay",
                Description = "",
                Default = "6",
                Min = 1,
                Max = 10,
                Rounding = 0.1,
                Callback = function(Value)
                    DungeonDelay2 = Value
                end
            }
        )

        Tabs.dungeon:AddSection("Runes")
        
        Tabs.dungeon:AddDropdown("DungeonRuneDropdown", {
            Title = "Select Dungeon Runes",
            Values = getRuneDropdownValues(),
            Multi = true,
            Default = {},
            Callback = function(val)
                selectedDungeonRunes = {}
                for displayName, isSelected in pairs(val) do
                    if isSelected then
                        local folderName = displayToFolder[displayName]
                        table.insert(selectedDungeonRunes, folderName)
                    end
                end
            end
        })
        
        Tabs.dungeon:AddButton({
            Title = "Refresh Rune List",
            Callback = function()
                local dropdown = Fluent.Options.DungeonRuneDropdown
                if dropdown then
                    dropdown:SetValues(getRuneDropdownValues())
                end
            end
        })
        
        Tabs.dungeon:AddToggle("AutoUseDungeonRune", {
            Title = "Auto Use Selected Runes",
            Default = false,
            Callback = function(state)
                autoUseDungeonRune = state
            end
        })

        Tabs.dungeon:AddSection("Auto Rejoin Dungeon")

        local autoRejoinDungeonEnabled = false
        
        local function autoRejoinDungeonLoop()
            while autoRejoinDungeonEnabled do
                local dungeonInfo = game:GetService("Players").LocalPlayer.PlayerGui.Hud.UpContanier.DungeonInfo.TextLabel
                if dungeonInfo and dungeonInfo.Text:find("Dungeon Ends in") then
                    task.wait(autoRejoinDelay)
                    local argsList = {
                        {
                            [1] = {
                                [1] = {
                                    ["Type"] = "Gems",
                                    ["Action"] = "BuyTicket",
                                    ["Event"] = "DungeonAction"
                                },
                                [2] = orosbucocugu
                            }
                        }
                    }
                    for _, args in ipairs(argsList) do
                        game:GetService("ReplicatedStorage").BridgeNet2.dataRemoteEvent:FireServer(unpack(args))
                    end
        
                    task.wait(0.5)
                    local argsCreate = {
                        [1] = {
                            [1] = {
                                ["Action"] = "Create",
                                ["Event"] = "DungeonAction"
                            },
                            [2] = orosbucocugu
                        }
                    }
                    game:GetService("ReplicatedStorage").BridgeNet2.dataRemoteEvent:FireServer(unpack(argsCreate))
                    
                    task.wait(0.5)
                    
                    if (autoUseDungeonRune == true or autoUseDungeonRejoinRune == true) and #selectedDungeonRunes > 0 then
                        print("[DEBUG] Adding runes:", table.concat(selectedDungeonRunes, ", "))
                    
                        local slot = 1
                        for _, runeName in ipairs(selectedDungeonRunes) do
                            for i = 1, 6 do
                                local addArgs = {
                                    [1] = {
                                        [1] = {
                                            ["Dungeon"] = player.UserId,
                                            ["Action"] = "AddItems",
                                            ["Slot"] = slot,
                                            ["Event"] = "DungeonAction",
                                            ["Item"] = runeName
                                        },
                                        [2] = orosbucocugu
                                    }
                                }
                    
                                remote:FireServer(unpack(addArgs))
                                print("[DEBUG] Added rune:", runeName, "Slot:", slot)
                                task.wait(0.1)
                    
                                slot += 1
                            end
                        end
                    end
                    
                    
                    task.wait(0.5)
                    local player = game:GetService("Players").LocalPlayer
                    local argsStart = {
                        [1] = {
                            [1] = {
                                ["Dungeon"] = player.UserId,
                                ["Action"] = "Start",
                                ["Event"] = "DungeonAction"
                            },
                            [2] = orosbucocugu
                        }
                    }
                    game:GetService("ReplicatedStorage").BridgeNet2.dataRemoteEvent:FireServer(unpack(argsStart))
                    repeat task.wait(1) until not (dungeonInfo and dungeonInfo.Text:find("Dungeon Ends in")) or not autoRejoinDungeonEnabled
                end
                task.wait(0.2)
            end
        end
        
        Tabs.dungeon:AddSlider(
            "AutoRejoinDelay",
            {
                Title = "Auto Rejoin Delay",
                Description = "",
                Default = 1,
                Min = 0,
                Max = 30,
                Rounding = 0.1,
                Callback = function(val)
                    autoRejoinDelay = tonumber(val)
                end
            }
        )
        
        Tabs.dungeon:AddToggle(
            "AutoRejoinDungeon",
            {
                Title = "Auto Rejoin Dungeon (Close Leave Fast)",
                Default = false,
                Callback = function(state)
                    autoRejoinDungeonEnabled = state
                    if state then
                        task.spawn(autoRejoinDungeonLoop)
                    end
                end
            }
        )
        
        Tabs.dungeon:AddToggle(
            "AutoRejoinRuneDungeon",
            {
                Title = "Auto Rejoin Dungeon Use Rune",
                Default = false,
                Callback = function(state)
                    autoUseDungeonRejoinRune = state
                end
            }
        )

        local leaveFastEnabled = false
        
        local function checkDungeonEndText()
            while leaveFastEnabled do
                local dungeonInfo = game:GetService("Players").LocalPlayer.PlayerGui.Hud.UpContanier.DungeonInfo.TextLabel
                if dungeonInfo and dungeonInfo.Text:find("Dungeon Ends in") then
                    game:GetService("TeleportService"):Teleport(87039211657390, game.Players.LocalPlayer)
                    break
                end
                task.wait(0.1)
            end
        end
        
        Tabs.dungeon:AddToggle(
            "LeaveFastDungeon",
            {
                Title = "Leave Fast Dungeon",
                Default = false,
                Callback = function(state)
                    leaveFastEnabled = state
                    if state then
                        task.spawn(checkDungeonEndText)
                    end
                end
            }
        )

        local function autoDetectDoubleDungeon()
    local inDoubleDungeon = false
    local savedRejoinState = false
    
    while waitdouble do
        local dungeonInfo = game:GetService("Players").LocalPlayer.PlayerGui.Hud.UpContanier.DungeonInfo.TextLabel
        
        if dungeonInfo then
            if dungeonInfo.Text:find("Double Dungeon Appear") and not inDoubleDungeon then
                inDoubleDungeon = true
                savedRejoinState = autoRejoinDungeonEnabled

                if autoRejoinDungeonEnabled then
                    Fluent:Notify({
                        Title = "Double Dungeon",
                        Content = "Double dungeon detected! Auto rejoin paused.",
                        Duration = 5
                    })
                    autoRejoinDungeonEnabled = false
                end

            elseif inDoubleDungeon and dungeonInfo.Text:find("Dungeon Ends in") then
                inDoubleDungeon = false

                if savedRejoinState then
                    task.wait(1)
                    autoRejoinDungeonEnabled = true
                    Fluent:Notify({
                        Title = "Double Dungeon",
                        Content = "Double dungeon completed. Auto rejoin restored.",
                        Duration = 5
                    })
                end
            end
        end
        
        task.wait(0.01)
    end
end

Tabs.dungeon:AddToggle(
    "DoubleDungeonToggle",
    {
        Title = "Wait for Double Dungeon",
        Default = false,
        Callback = function(state)
            waitdouble = state
            if state then
                task.spawn(autoDetectDoubleDungeon)
            end
        end
    }
)
        
Tabs.dungeon:AddSection("Dungeon Stuck Rejoin")
Tabs.dungeon:AddDropdown("DungeonRoomRejoinMinutes", {
    Title = "Rejoin If Stuck (Minutes)",
    Values = {"1","2","3","4","5","6","7","8","9","10"},
    Multi = false,
    Default = "3",
    Callback = function(val)
        dungeonRoomRejoinMinutes = tonumber(val)
    end
})
Tabs.dungeon:AddToggle("DungeonRoomRejoinToggle", {
    Title = "Enable Stuck Room Rejoin",
    Default = false,
    Callback = function(state)
        dungeonRoomRejoinEnabled = state
    end
})

local function dungeonRoomStuckRejoinLoop()
    local lastRoom = nil
    local lastRoomChange = os.clock()
    while dungeonRoomRejoinEnabled and game.PlaceId == 128336380114944 do
        local roomLabel = player.PlayerGui and player.PlayerGui:FindFirstChild("Hud") and player.PlayerGui.Hud:FindFirstChild("UpContanier") and player.PlayerGui.Hud.UpContanier:FindFirstChild("Room")
        local roomText = roomLabel and roomLabel.Text or ""
        if roomText ~= lastRoom then
            lastRoom = roomText
            lastRoomChange = os.clock() 
        end
        if lastRoom and (os.clock() - lastRoomChange) >= (dungeonRoomRejoinMinutes * 60) then
            Fluent:Notify({
                Title = "Dungeon Rejoin",
                Content = "Rejoining dungeon (stuck in same room for "..dungeonRoomRejoinMinutes.." min)",
                Duration = 5
            })

            local argsList = {
                {
                    [1] = {
                        [1] = {
                            ["Type"] = "Gems",
                            ["Action"] = "BuyTicket",
                            ["Event"] = "DungeonAction"
                        },
                        [2] = orosbucocugu
                    }
                }
            }
            for _, args in ipairs(argsList) do
                game:GetService("ReplicatedStorage").BridgeNet2.dataRemoteEvent:FireServer(unpack(args))
            end

            task.wait(0.5)
            local argsCreate = {
                [1] = {
                    [1] = {
                        ["Action"] = "Create",
                        ["Event"] = "DungeonAction"
                    },
                    [2] = orosbucocugu
                }
            }
            game:GetService("ReplicatedStorage").BridgeNet2.dataRemoteEvent:FireServer(unpack(argsCreate))
            
            task.wait(0.5)
            if autoUseDungeonRejoinRune == true and #selectedDungeonRunes > 0 then
                for _, runeName in ipairs(selectedDungeonRunes) do
                    local addArgs = {
                        [1] = {
                            [1] = {
                                ["Dungeon"] = player.UserId,
                                ["Action"] = "AddItems",
                                ["Slot"] = 1,
                                ["Event"] = "DungeonAction",
                                ["Item"] = runeName
                            },
                            [2] = orosbucocugu
                        }
                    }
                    remote:FireServer(unpack(addArgs))
                    task.wait(0.1)
                end
            end

            task.wait(0.5)
            local argsStart = {
                [1] = {
                    [1] = {
                        ["Dungeon"] = player.UserId,
                        ["Action"] = "Start",
                        ["Event"] = "DungeonAction"
                    },
                    [2] = orosbucocugu
                }
            }
            game:GetService("ReplicatedStorage").BridgeNet2.dataRemoteEvent:FireServer(unpack(argsStart))
            break
        end
        task.wait(1)
    end
end

task.spawn(function()
    while true do
        if dungeonRoomRejoinEnabled and game.PlaceId == 128336380114944 then
            dungeonRoomStuckRejoinLoop()
        end
        task.wait(2)
    end
end)
        
        Tabs.dungeon:AddSection("Advanced Dungeon Options")
        
        local bypassDungeonEnabled = false
        
        Tabs.dungeon:AddButton({
            Title = "Bypass Dungeon",
            Description = "",
            Callback = function()  
                    local argsList = {
                        {
                            [1] = {
                                [1] = {
                                    ["Type"] = "Gems",
                                    ["Action"] = "BuyTicket",
                                    ["Event"] = "DungeonAction"
                                },
                                [2] = orosbucocugu
                            }
                        }
                    }
                    for _, args in ipairs(argsList) do
                        game:GetService("ReplicatedStorage").BridgeNet2.dataRemoteEvent:FireServer(unpack(args))
                    end

            local args = {
                [1] = {
                [1] = {
                    ["Action"] = "Create",
                    ["Event"] = "DungeonAction"
                },
                [2] = orosbucocugu
                }
            }
            game:GetService("ReplicatedStorage"):WaitForChild("BridgeNet2"):WaitForChild("dataRemoteEvent"):FireServer(unpack(args))
            task.wait(0.1)
            
            local startArgs = {
                [1] = {
                [1] = {
                    ["Dungeon"] = game:GetService("Players").LocalPlayer.UserId,
                    ["Action"] = "Start",
                    ["Event"] = "DungeonAction"
                },
                [2] = orosbucocugu
                }
            }
            game:GetService("ReplicatedStorage"):WaitForChild("BridgeNet2"):WaitForChild("dataRemoteEvent"):FireServer(unpack(startArgs))
            end
        })
    end)


    task.spawn(function()
        task.wait(0.1)
          Tabs.castle:AddSection("Auto Castle Farm")
        Tabs.castle:AddParagraph(
            {
                Title = "Castle Farm",
                Content = "If you select 'False', checkpoints will not be used and your floors will progress as 1, 2, 3, etc."
            }
        )

        Tabs.castle:AddDropdown(
            "CastleCheckpoint",
            {
                Title = "Castle Checkpoint",
                Values = {"False", "10", "20", "50", "70", "100"},
                Multi = false,
                Default = "False",
                Callback = function(Value)
                    selectedCheckpoint = Value
                end
            }
        )
        
        Tabs.castle:AddToggle(
            "EnableCheckpoints",
            {
                Title = "Enable Checkpoints",
                Default = false,
                Callback = function(Value)
                    checkpointsEnabled = Value
                end
            }
        )
                
                    Tabs.castle:AddDropdown(
                    "CastleFarmMethod",
                    {
                        Title = "Farm Method",
                        Values = {"Teleport", "Tween"},
                        Multi = false,
                        Default = "Teleport",
                        Callback = function(Value)
                            castleFarmMethod = Value
                        end
                    }
                )
                
                Tabs.castle:AddToggle(
                    "CastleFarm",
                    {
                        Title = "Auto Farm Castle",
                        Default = false,
                        Callback = function(state)
                            if state and isInDungeon() then
                                Fluent:Notify({
                                    Title = "Warning",
                                    Content = "You cannot start Castle Farm while in Dungeon!",
                                    Duration = 4
                                })
                                return
                            end
                            castleFarmEnabled = state
                            if state then
                                if game.PlaceId == 128336380114944 then
                                    task.spawn(teleportCastleFarmMain)
                                    game:GetService("Players").LocalPlayer:SetAttribute("AutoClick", true)
                                else
                                    task.spawn(searchLoop)
                                end
                                task.spawn(
                                    function()
                                        while castleFarmEnabled do
                                            wait(20)
                                            if castleFarmEnabled then
                                                castleFarmEnabled = false
                                                castlekill = {}
                                                wait(1)
                                                castleFarmEnabled = true
                                                if game.PlaceId == 128336380114944 then
                                                    task.spawn(teleportCastleFarmMain)
                                                    game:GetService("Players").LocalPlayer:SetAttribute("AutoClick", true)
                                                else
                                                    task.spawn(searchLoop)
                                                end
                                            end
                                        end
                                    end
                                )
                            else
                                castlekill = {}
                            end
                        end
                    }
                )
                

                Tabs.castle:AddSection("Other Castle Options")

                Tabs.castle:AddToggle(
                    "CastleBossPriority",
                    {
                        Title = "Prioritize Bosses",
                        Default = false,
                        Callback = function(state)
                            castleBossPriorityEnabled = state
                        end
                    }
                )
                
                
                Tabs.castle:AddToggle(
                    "AutoResetCastle",
                    {
                        Title = "Auto Reset Castle (Gems)",
                        Default = false,
                        Callback = function(state)
                            autoResetCastleEnabled = state
                            if state then
                                task.spawn(function()
                                    while autoResetCastleEnabled do
                                        if game.PlaceId == 87039211657390 then
                                            local argsList = {
                                                {
                                                    [1] = {
                                                        [1] = {
                                                            ["Type"] = "Gems",
                                                            ["Action"] = "BuyTicket",
                                                            ["Event"] = "CastleAction"
                                                        },
                                                        [2] = orosbucocugu
                                                    }
                                                }
                                            }
                                            for _, args in ipairs(argsList) do
                                                game:GetService("ReplicatedStorage").BridgeNet2.dataRemoteEvent:FireServer(unpack(args))
                                            end
                                        end
                                        task.wait(0.5)
                                    end
                                end)
                            end
                        end
                    }
                )
                
                Tabs.castle:AddSection("Farm Settings")
                
                Tabs.castle:AddSlider(
                    "CastleDelay",
                    {
                        Title = "Castle Farm Delay",
                        Description = "",
                        Default = 0.7,
                        Min = 0.1,
                        Max = 2,
                        Rounding = 1,
                        Callback = function(Value)
                            CastleDelay = Value
                        end
                    }
                )
                
                Tabs.castle:AddSlider(
                    "CastleTweenSpeed",
                    {
                        Title = "Tween Speed",
                        Description = "",
                        Default = castleTweenSpeed,
                        Min = 0.1,
                        Max = 3.0,
                        Rounding = 1,
                        Callback = function(Value)
                            castleTweenSpeed = Value
                        end
                    }
                )
                
                Tabs.castle:AddInput(
                    "ExitFloor",
                    {
                        Title = "Exit at Floor",
                        Description = "Enter floor number (max 100)",
                        Default = tostring(targetFloor),
                        Placeholder = "Enter floor (1-100)",
                        Numeric = true,
                        Finished = true,
                        Callback = function(value)
                            local num = tonumber(value)
                            if num then
                                targetFloor = math.min(math.max(1, num), 100)
                            end
                        end
                    }
                )

                Tabs.castle:AddSection("Leave Dungeon on Castle Time")

                Tabs.castle:AddDropdown("CastleDungeonExitMode", {
                    Title = "Dungeon Exit Mode",
                    Values = {"Wait for Dungeon to End", "Leave Before Dungeon Ends"},
                    Multi = false,
                    Default = "Wait for Dungeon to End",
                    Callback = function(val)
                        castleDungeonExitMode = val
                    end
                })
                
        
                Tabs.castle:AddToggle("AutoExitDungeonForCastle", {
                    Title = "Leave Dungeon When Castle Time",
                    Default = false,
                    Callback = function(state)
                        autoExitDungeonForCastle = state
                        if state then
                            task.spawn(function()
                                while autoExitDungeonForCastle do
                                    local isCastleNow = isCastleTimeGlobal()
                                    if isCastleNow and isInDungeon() and game.PlaceId ~= 87039211657390 then
                                        if castleDungeonExitMode == "Leave Before Dungeon Ends" then
                                            game:GetService("TeleportService"):Teleport(87039211657390, game.Players.LocalPlayer)
                                            break
                                        elseif castleDungeonExitMode == "Wait for Dungeon to End" then
                                            local dungeonInfo = game:GetService("Players").LocalPlayer.PlayerGui.Hud.UpContanier.DungeonInfo.TextLabel
                                            while autoExitDungeonForCastle and isInDungeon() and game.PlaceId ~= 87039211657390 do
                                                if dungeonInfo and dungeonInfo.Text:find("Dungeon Ends in") then
                                                    game:GetService("TeleportService"):Teleport(87039211657390, game.Players.LocalPlayer)
                                                    break
                                                end
                                                task.wait(0.5)
                                            end
                                        end
                                    end
                                    task.wait(2)
                                end
                            end)
                        end
                    end
                })
                
                Tabs.castle:AddSection("Return Position Management")
                Tabs.castle:AddToggle("CastleReturnAfterFarm", {
                    Title = "Return to Saved CFrame After Castle",
                    Default = false,
                    Callback = function(state)
                        castleReturnEnabled = state
                        if state and not isfile("castle_return_cframe.txt") then
                            if player.Character and player.Character:FindFirstChild("HumanoidRootPart") then
                                saveCastleReturnCFrame(player.Character.HumanoidRootPart.CFrame)
                                Fluent:Notify({
                                    Title = "Castle Return",
                                    Content = "Current position saved for castle return.",
                                    Duration = 3
                                })
                            end
                        end
                    end
                })

                Tabs.castle:AddButton({
                    Title = "Save Current Position for Castle Return",
                    Description = "Saves your current position to return after castle.",
                    Callback = function()
                        if player.Character and player.Character:FindFirstChild("HumanoidRootPart") then
                            saveCastleReturnCFrame(player.Character.HumanoidRootPart.CFrame)
                            Fluent:Notify({
                                Title = "Castle Return",
                                Content = "Current position saved for castle return.",
                                Duration = 3
                            })
                        end
                    end
                })
                
                task.spawn(function()
                    task.wait(2)
                    if castleReturnEnabled and game.PlaceId == 87039211657390 then
                        local cf = loadCastleReturnCFrame()
                        if cf then
                            task.wait(1)
                            if player.Character and player.Character:FindFirstChild("HumanoidRootPart") then
                                player.Character.HumanoidRootPart.CFrame = cf
                                Fluent:Notify({
                                    Title = "Castle Return",
                                    Content = "Teleported to saved position after castle.",
                                    Duration = 3
                                })
                            end
                        end
                    end
                end)
    end)
    
    task.spawn(function()
        task.wait(0.2) -- Wait a bit longer for this heavier tab
        Tabs.tp:AddSection("World Teleports")
        
        
        local useDirectTeleport = false
        
        local function SetSpawnAndReset(worldName)
            if useDirectTeleport then
                local spawnFolder = workspace:FindFirstChild("__Extra") and workspace.__Extra:FindFirstChild("__Spawns")
                
                if spawnFolder then
                    local spawnPart = spawnFolder:FindFirstChild(worldName)
                    if spawnPart and spawnPart:IsA("SpawnLocation") then
                        local hrp = game.Players.LocalPlayer.Character and game.Players.LocalPlayer.Character:FindFirstChild("HumanoidRootPart")
                        if hrp then
                            anticheat()
                            hrp.CFrame = spawnPart.CFrame * CFrame.new(0, 3, 0)
                            return
                        end
                    end
                end
                
                Fluent:Notify({
                    Title = "Teleport Failed",
                    Content = "Could not find spawn location for " .. worldName,
                    Duration = 3
                })
            else
                remote:FireServer({
                    {
                        ["Event"] = "ChangeSpawn",
                        ["Spawn"] = worldName
                    },
                    orosbucocugu
                })
        
                task.wait(0.5)
        
                if game.Players.LocalPlayer.Character then
                    game.Players.LocalPlayer.Character:BreakJoints()
                end
            end
        end
        
        Tabs.tp:AddToggle("DirectTeleport", {
            Title = "Direct Teleport (No Spawn Change)",
            Default = false,
            Callback = function(state)
                useDirectTeleport = state
            end
        })
        
        Tabs.tp:AddButton({
            Title = "Leveling City",
            Description = "Teleport to Leveling City",
            Callback = function()
                SetSpawnAndReset(villageSpawns["Leveling City"])
            end
        })
        
        Tabs.tp:AddButton({
            Title = "Grass Village",
            Description = "Teleport to Grass Village",
            Callback = function()
                SetSpawnAndReset(villageSpawns["Grass Village"])
            end
        })
        
        Tabs.tp:AddButton({
            Title = "Brum Island",
            Description = "Teleport to Brum Island",
            Callback = function()
                SetSpawnAndReset(villageSpawns["Brum Island"])
            end
        })
        
        Tabs.tp:AddButton({
            Title = "Faceheal Town",
            Description = "Teleport to Faceheal Town",
            Callback = function()
                SetSpawnAndReset(villageSpawns["Faceheal Town"])
            end
        })
        
        Tabs.tp:AddButton({
            Title = "Lucky Kingdom",
            Description = "Teleport to Lucky Kingdom",
            Callback = function()
                SetSpawnAndReset(villageSpawns["Lucky Kingdom"])
            end
        })
        
        Tabs.tp:AddButton({
            Title = "Nipon City",
            Description = "Teleport to Nipon City",
            Callback = function()
                SetSpawnAndReset(villageSpawns["Nipon City"])
            end
        })
        
        Tabs.tp:AddButton({
            Title = "Mori Town",
            Description = "Teleport to Mori Town",
            Callback = function()
                SetSpawnAndReset(villageSpawns["Mori Town"])
            end
        })
        
        Tabs.tp:AddButton({
            Title = "Dragon Ball",
            Description = "Teleport to Dragon Ball",
            Callback = function()
                SetSpawnAndReset(villageSpawns["Dragon Ball"])
            end
        })
        
        Tabs.tp:AddButton({
            Title = "One Punch Man",
            Description = "Teleport to One Punch",
            Callback = function()
                SetSpawnAndReset(villageSpawns["One Punch"])
            end
        })

        Tabs.tp:AddButton({
            Title = "Kindama City",
            Description = "Teleport to Kindama City",
            Callback = function()
                SetSpawnAndReset(villageSpawns["Kindama City"])
            end
        })
        
        Tabs.tp:AddButton({
            Title = "Hunters City",
            Description = "Teleport to Hunters City",
            Callback = function()
                SetSpawnAndReset(villageSpawns["Hunters City"])
            end
        })

        player.CharacterAdded:Connect(
            function(newCharacter)
                character = newCharacter
                hrp = newCharacter:WaitForChild("HumanoidRootPart") -- Get the new HRP after respawn
            end
        )

        local function teleportWithTween(targetCFrame)
            if hrp then
                local tweenInfo =
                    TweenInfo.new(
                    2,
                    Enum.EasingStyle.Sine,
                    Enum.EasingDirection.Out,
                    0,
                    false, 
                    0 
                )
        
                local tweenGoal = {CFrame = targetCFrame}
                local tween = TweenService:Create(hrp, tweenInfo, tweenGoal)
                tween:Play()
            end
        end
        
        Tabs.pets:AddSection("Sell Pet")
        
        local rankMapping = {
            [1] = "E",
            [2] = "D",
            [3] = "C",
            [4] = "B",
            [5] = "A",
            [6] = "S",
            [7] = "SS",
            [8] = "G",
            [9] = "N"
        }
        
        local rankValues = {}
        for i = 1, 9 do
            table.insert(rankValues, rankMapping[i] .. " (Rank " .. i .. ")")
        end
        
        local selectedRanks = {}
        local autoSellEnabled = false
        
        Tabs.pets:AddDropdown("RankDropdown", {
            Title = "Choose Ranks to Sell",
            Values = rankValues,
            Multi = true,
            Default = {},
            Callback = function(selections)
                selectedRanks = {}
                if type(selections) == "table" then
                    for selection, isSelected in pairs(selections) do
                        if isSelected == true then
                            local rankStr = selection:match("Rank (%d+)")
                            if rankStr then
                                local rank = tonumber(rankStr)
                                if rank then
                                    table.insert(selectedRanks, rank)
                                end
                            end
                        end
                    end
                end
            end
        })
        
        local function sellPetsByRank()
            local petFolder = player.leaderstats.Inventory:WaitForChild("Pets")
            local petsToSell = {}
            
            for _, pet in ipairs(petFolder:GetChildren()) do
                local rankVal = pet:GetAttribute("Rank")
                local isLocked = pet:GetAttribute("Locked") or false
                if typeof(rankVal) == "number" and table.find(selectedRanks, rankVal) and not isLocked then
                    table.insert(petsToSell, pet.Name)
                    if #petsToSell >= 20 then
                        
                        local args = {
                            [1] = {
                                [1] = {
                                    ["Event"] = "SellPet",
                                    ["Pets"] = petsToSell
                                },
                                [2] = degisiklik2
                            }
                        }
                        remote:FireServer(unpack(args))
                        task.wait(0.3)
                        petsToSell = {}
                    end
                end
            end
            if #petsToSell > 0 then
                local args = {
                    [1] = {
                        [1] = {
                            ["Event"] = "SellPet",
                            ["Pets"] = petsToSell
                        },
                        [2] = degisiklik2
                    }
                }
                remote:FireServer(unpack(args))
            end
        end
        
        Tabs.pets:AddButton({
            Title = "Sell Now",
            Description = "Sell all pets with selected ranks immediately",
            Callback = function()
                if #selectedRanks > 0 then
                    sellPetsByRank()
                else
                    Fluent:Notify({
                        Title = "No rank selected",
                        Content = "Please select at least one rank to sell pets",
                        Duration = 3
                    })
                end
            end
        })
        
        Tabs.pets:AddToggle("AutoSellToggle", {
            Title = "Auto Sell Pets",
            Default = autoSellEnabled,
            Callback = function(state)
                autoSellEnabled = state
                if state then
                    if #selectedRanks > 0 then
                        Fluent:Notify({
                            Title = "Auto Sell enabled",
                            Content = "Will automatically sell pets with ranks: " .. table.concat(selectedRanks, ", "),
                            Duration = 3
                        })
                        task.spawn(function()
                            while autoSellEnabled do
                                sellPetsByRank()
                                task.wait(5)
                            end
                        end)
                    else
                        Fluent:Notify({
                            Title = "No rank selected",
                            Content = "Please select at least one rank to sell pets",
                            Duration = 3
                        })
                    end
                end
            end
        })
        
        Tabs.pets:AddSection("Choose Pets")
        
        Tabs.pets:AddParagraph({
            Title = "Pet Protection Info",
            Content = "Locked pets will not be sold.\nLock your pets to prevent them from being deleted!"
        })
        
        local selectedShop = "WeaponShop1"
        local selectedWeapon = ""
        local autoBuyEnabled = false
        local selectedWeaponType = ""
        local autoSelectedEnabled = false
        local weaponBuyAmount = 1  -- Default amount value
        
        local weaponsByShop = {
            ["WeaponShop1"] = {"SpikeMace", "GemStaff", "DualKando", "CrystalScepter", "DualBoneMace", "DualSteelNaginata"}, 
            ["WeaponShop2"] = {"MonsterSlayer", "DualBasicStaffs", "PirateSaber", "MixedBattleAxe", "BronzeGreatAxe", "DualAncientMace"},
            ["WeaponShop3"] = {"DualPirateSaber", "DualSteelSabers", "SteelSaber", "SteelButterfly", "DualSteelButterfly", "SteelKando"},
            ["WeaponShop4"] = {"SteelNaginata", "GreatKopesh", "BoneMace", "AncientMace", "CrimsonStaff", "GreatSaber"},
            ["WeaponShop5"] = {"DualGreatSaber", "BasicStaff", "StellKopesh", "GreatTrident", "DualCrystalScepter", "DualTrident"},
            ["WeaponShop6"] = {"OzSword2", "CrystalSword2", "ObsidianDualAxe2", "SilverSpear2", "DragonAxe2", "DualDivineAxe2"},
            ["WeaponShop7"] = {"BloodStaff2", "DualCrimsonStaff2", "DualGemStaffs2", "GreatScythe2", "TwinObsidianDualStaff2", "SlayerScythe2"},
            ["WeaponShop8"] = {"BeholderStaff2", "TwinMixedAxe2", "TwinTrollSlayer2", "RuneAxe2", "DualSilverSpear2", "DualDragonAxe2"},
            ["WeaponShop9"] = {"SteelSword2", "SteelSpear2", "StarSpear2", "BoneStaff2", "SunGreatAxe2", "EnergyGreatSword2"},
            ["WeaponShop10"] = {"SteelAxe2", "SteelGreatAxe2", "TwinBeholderStaffs2", "ObisidianGlaive2", "DualSunGreatAxe2", "DivineHammer2"},
            ["WeaponShop11"] = {"CrossSword2", "DualDivineBattleAxe2", "EyeSword2", "FaithSword2", "DualKrakenSword2", "ArchamageStaff2"}
        }
        
        local weaponPrices = {
            -- Shop 1
            SpikeMace = "80",
            GemStaff = "180",
            DualKando = "400",
            CrystalScepter = "900",
            DualBoneMace = "2K",
            DualSteelNaginata = "4.5K",
            -- Shop 2
            MonsterSlayer = "10K",
            DualBasicStaffs = "22K",
            PirateSaber = "49K",
            MixedBattleAxe = "110K",
            BronzeGreatAxe = "242K",
            DualAncientMace = "535K",
            -- Shop 3
            DualPirateSaber = "1.2M",
            DualSteelSabers = "2.5M",
            SteelSaber = "5.65M",
            SteelButterfly = "12.5M",
            DualSteelButterfly = "27.5M",
            SteelKando = "60M",
            -- Shop 4
            SteelNaginata = "132M",
            GreatKopesh = "290M",
            BoneMace = "630M",
            AncientMace = "1.4B",
            CrimsonStaff = "3B",
            GreatSaber = "6.7B",
            -- Shop 5
            DualGreatSaber = "14.07B",
            BasicStaff = "28.14B",
            StellKopesh = "56.28B",
            GreatTrident = "112.56B",
            DualCrystalScepter = "223.11B",
            DualTrident = "446.22B",
            -- Shop 6
            OzSword2 = "840B",
            CrystalSword2 = "1.68T",
            ObsidianDualAxe2 = "3.36T",
            SilverSpear2 = "6.72T",
            DragonAxe2 = "13.32T",
            DualDivineAxe2 = "26.64T",
            -- Shop 7
            BloodStaff2 = "42T",
            DualCrimsonStaff2 = "84T",
            DualGemStaffs2 = "168T",
            GreatScythe2 = "336T",
            TwinObsidianDualStaff2 = "666T",
            SlayerScythe2 = "1.33Qa",
            -- Shop 8
            BeholderStaff2 = "2.73Qa",
            TwinMixedAxe2 = "5.46Qa",
            TwinTrollSlayer2 = "10.92Qa",
            RuneAxe2 = "21.84Qa",
            DualSilverSpear2 = "43.29Qa",
            DualDragonAxe2 = "86.58Qa",
            -- Shop 9
            SteelSword2 = "169.13Qa",
            SteelSpear2 = "338.26Qa",
            StarSpear2 = "559.52Qa",
            BoneStaff2 = "1.12Qi",
            SunGreatAxe2 = "2.41Qi",
            EnergyGreatSword2 = "5.20Qi",
            -- Shop 10
            SteelAxe2 = "10.66Qi",
            SteelGreatAxe2 = "21.58Qi",
            TwinBeholderStaffs2 = "44.98Qi",
            ObisidianGlaive2 = "91.78Qi",
            DualSunGreatAxe2 = "195.78Qi",
            DualDivineHammer2 = "422.50Qi",
            -- Shop 11
            CrossSword2 = "887.25Qi",
            DualDivineBattleAxe2 = "1.90Sx",
            EyeSword2 = "3.80Sx",
            FaithSword2 = "7.60Sx",
            DualKrakenSword2 = "15.21Sx",
            ArchamageStaff2 = "30.42Sx"            
        }
        
        local function getDisplayValues(weapons)
            local displayValues = {}
            for _, weapon in ipairs(weapons) do
            local price = weaponPrices[weapon] or ""
            table.insert(displayValues, weapon .. " - " .. price)
            end
            return displayValues
        end
        
        local shopDisplayNames = {
            ["WeaponShop1"] = "Leveling City",
            ["WeaponShop2"] = "Grass Village", 
            ["WeaponShop3"] = "Brum Island",
            ["WeaponShop4"] = "Faceheal Town",
            ["WeaponShop5"] = "Lucky Kingdom",
            ["WeaponShop6"] = "Nipon City",
            ["WeaponShop7"] = "Mori Town",
            ["WeaponShop8"] = "Dragon Ball",
            ["WeaponShop9"] = "One Punch",
            ["WeaponShop10"] = "Kindama City",
            ["WeaponShop11"] = "Hunters City"
        }
        
        local function getInternalShopName(displayName)
            for internal, display in pairs(shopDisplayNames) do
            if display == displayName then
                return internal
            end
            end
            return displayName
        end
        
        Tabs.misc:AddSection("Buy Weapon")
        
        Tabs.misc:AddDropdown("ShopDropdown", {
            Title = "Select Shop",
            Values = {"Leveling City", "Grass Village", "Brum Island", "Faceheal Town", "Lucky Kingdom", "Nipon City", "Mori Town", "Dragon Ball", "One Punch", "Kindama City", "Hunters City"},
            Multi = false,
            Default = shopDisplayNames[selectedShop],
            Callback = function(displayName)
            selectedShop = getInternalShopName(displayName)
            local weaponDropdown = Fluent.Options.WeaponDropdown
            if weaponDropdown then
                weaponDropdown:SetValues(getDisplayValues(weaponsByShop[selectedShop] or {}))
                if #weaponsByShop[selectedShop] > 0 then
                selectedWeapon = weaponsByShop[selectedShop][1]
                weaponDropdown:SetValue(selectedWeapon .. " - " .. (weaponPrices[selectedWeapon] or ""))
                else
                selectedWeapon = ""
                end
            end
            end
        })
        
        Tabs.misc:AddDropdown("WeaponDropdown", {
            Title = "Select Weapon",
            Values = getDisplayValues(weaponsByShop[selectedShop] or {}),
            Multi = false,
            Default = selectedWeapon and (selectedWeapon .. " - " .. (weaponPrices[selectedWeapon] or "")) or "",
            Callback = function(selection)
            selectedWeapon = selection:match("^([^%s-]+)")
            end
        })
        
        -- Add slider for amount control
        Tabs.misc:AddSlider("WeaponBuyAmount", {
            Title = "Purchase Amount",
            Description = "Set how many weapons to purchase at once",
            Default = 1,
            Min = 1,
            Max = 100,
            Rounding = 0,
            Callback = function(Value)
            weaponBuyAmount = Value
            end
        })
        
        local function buyWeapon()
            if selectedShop and selectedWeapon and selectedWeapon ~= "" then
            
            local args = {
                [1] = {
                [1] = {
                    ["Action"] = "Buy",
                    ["Shop"] = selectedShop,
                    ["Item"] = selectedWeapon,
                    ["Amount"] = weaponBuyAmount, -- Use the variable controlled by slider
                    ["Event"] = "ItemShopAction"
                },
                [2] = orosbucocugu
                }
            }
            remote:FireServer(unpack(args))
            print("Purchased:", weaponBuyAmount, "x", selectedWeapon, "from shop:", selectedShop)
            else
            print("Please select a shop and weapon!")
            end
        end
        
        Tabs.misc:AddToggle("AutoBuyToggle", {
            Title = "Auto Buy Weapon",
            Default = autoBuyEnabled,
            Callback = function(state)
            autoBuyEnabled = state
            if state then
                task.spawn(function()
                while autoBuyEnabled do
                    buyWeapon()
                    task.wait(1)
                end
                end)
            end
            end
        })
        Tabs.misc:AddSection("Upgrade Weapon")
        
        local function getUniqueWeaponNames()
            local weapons = {}
            local seenNames = {}
            local playerWeapons = player.leaderstats.Inventory.Weapons:GetChildren()
            for _, weapon in ipairs(playerWeapons) do
                local weaponName = weapon:GetAttribute("Name")
                if weaponName and not seenNames[weaponName] then
                    table.insert(weapons, weaponName)
                    seenNames[weaponName] = true
                end
            end
            return weapons
        end
        
        local function getWeaponsByLevel(weaponType)
            local weaponsByLevel = {}
            for i = 1, 7 do
                weaponsByLevel[i] = {}
            end
            local playerWeapons = player.leaderstats.Inventory.Weapons:GetChildren()
            for _, weapon in ipairs(playerWeapons) do
                local weaponName = weapon:GetAttribute("Name")
                local weaponLevel = weapon:GetAttribute("Level") or 1
                if (not weaponType or weaponType == "" or weaponName == weaponType) and weaponLevel >= 1 and weaponLevel <= 7 then
                    table.insert(weaponsByLevel[weaponLevel], weapon.Name)
                end
            end
            return weaponsByLevel
        end
        
        local function upgradeWeaponsByLevel(weaponType)
            local weaponsByLevel = getWeaponsByLevel(weaponType)
            local anyUpgraded = false
            for level = 1, 6 do
                local weapons = weaponsByLevel[level]
                while #weapons >= 3 do
                    local upgradeWeapons = {
                        weapons[1],
                        weapons[2],
                        weapons[3]
                    }
                    table.remove(weapons, 1)
                    table.remove(weapons, 1)
                    table.remove(weapons, 1)
                    local weaponName = player.leaderstats.Inventory.Weapons:FindFirstChild(upgradeWeapons[1]):GetAttribute("Name")
                    local args = {
                        [1] = {
                            [1] = {
                                ["Type"] = weaponName,
                                ["BuyType"] = "Gems",
                                ["Weapons"] = upgradeWeapons,
                                ["Event"] = "UpgradeWeapon",
                                ["Level"] = level + 1
                            },
                            [2] = orosbucocugu
                        }
                    }
                    remote:FireServer(unpack(args))
                    print("Upgrading", #upgradeWeapons, "weapons", weaponName, "from level", level, "to level", level + 1)
                    Fluent:Notify({
                        Title = "Upgrading",
                        Content = "Upgrading " .. weaponName .. " from level " .. level .. " to level " .. (level + 1),
                        Duration = 3
                    })
                    anyUpgraded = true
                    task.wait(1)
                end
            end
            if not anyUpgraded then
                Fluent:Notify({
                    Title = "Notice",
                    Content = "No weapons available to upgrade",
                    Duration = 3
                })
            end
            return anyUpgraded
        end
        
        local weaponTypes = getUniqueWeaponNames()
        local selectedWeaponType = weaponTypes[1] or ""
        local autoSelectedEnabled = false
        
        Tabs.misc:AddDropdown("WeaponTypeDropdown", {
            Title = "Select Weapon Type",
            Values = weaponTypes,
            Multi = false,
            Default = selectedWeaponType,
            Callback = function(weaponType)
                selectedWeaponType = weaponType
            end
        })
        
        Tabs.misc:AddButton({
            Title = "Refresh Weapon List",
            Description = "Refresh the list of available weapons",
            Callback = function()
                weaponTypes = getUniqueWeaponNames()
                local weaponTypeDropdown = Fluent.Options.WeaponTypeDropdown
                if weaponTypeDropdown then
                    weaponTypeDropdown:SetValues(weaponTypes)
                    if #weaponTypes > 0 and not table.find(weaponTypes, selectedWeaponType) then
                        selectedWeaponType = weaponTypes[1]
                        weaponTypeDropdown:SetValue(selectedWeaponType)
                    end
                end
                Fluent:Notify({
                    Title = "List Refreshed",
                    Content = "Updated available weapons list",
                    Duration = 3
                })
            end
        })
        
        Tabs.misc:AddToggle("AutoSelectToggle", {
            Title = "Upgrade Selected Weapon",
            Default = autoSelectedEnabled,
            Callback = function(state)
                autoSelectedEnabled = state
                if state then
                    if not selectedWeaponType or selectedWeaponType == "" then
                        Fluent:Notify({
                            Title = "Error",
                            Content = "Please select weapon type before upgrading",
                            Duration = 3
                        })
                        return
                    end
                    task.spawn(function()
                        while autoSelectedEnabled do
                            local upgraded = upgradeWeaponsByLevel(selectedWeaponType)
                            task.wait(upgraded and 1 or 5)
                        end
                    end)
                end
            end
        })
        
        
        -- WEAPON SELL SECTION
        Tabs.misc:AddSection("Sell Weapon")
        
        -- Damage thresholds for dropdown (up to 1Qa)
        local damageThresholds = {
            ["1K"] = 1000,
            ["5K"] = 5000,
            ["10K"] = 10000,
            ["25K"] = 25000,
            ["50K"] = 50000,
            ["75K"] = 75000,
            ["100K"] = 100000,
        
            ["1M"] = 1000000,
            ["5M"] = 5000000,
            ["10M"] = 10000000,
            ["25M"] = 25000000,
            ["50M"] = 50000000,
            ["75M"] = 75000000,
            ["100M"] = 100000000,
        
            ["1B"] = 1000000000,
            ["5B"] = 5000000000,
            ["10B"] = 10000000000,
            ["25B"] = 25000000000,
            ["50B"] = 50000000000,
            ["75B"] = 75000000000,
            ["100B"] = 100000000000,
        
            ["1T"] = 1000000000000,
            ["5T"] = 5000000000000,
            ["10T"] = 10000000000000,
            ["25T"] = 25000000000000,
            ["50T"] = 50000000000000,
            ["75T"] = 75000000000000,
            ["100T"] = 100000000000000,
        
            ["1Qa"] = 1000000000000000,
            ["5Qa"] = 5000000000000000,
            ["10Qa"] = 10000000000000000,
            ["25Qa"] = 25000000000000000,
            ["50Qa"] = 50000000000000000,
            ["75Qa"] = 75000000000000000,
            ["100Qa"] = 100000000000000000,
        }        
        
        local damageThresholdNames = {
            "1K", "5K", "10K", "25K", "50K", "75K", "100K",
            "1M", "5M", "10M", "25M", "50M", "75M", "100M",
            "1B", "5B", "10B", "25B", "50B", "75B", "100B",
            "1T", "5T", "10T", "25T", "50T", "75T", "100T",
            "1Qa", "5Qa", "10Qa", "25Qa", "50Qa", "75Qa", "100Qa"
        }        
        local selectedDamageThreshold = damageThresholds["1K"]
        local autoSellWeaponEnabled = false
        
        Tabs.misc:AddDropdown("WeaponDamageThreshold", {
            Title = "Choose Damage Threshold",
            Values = damageThresholdNames,
            Multi = false,
            Default = "1K",
            Callback = function(selection)
                selectedDamageThreshold = damageThresholds[selection] or 1000
            end
        })
        
        local function parseDamageText(damageText)
            local num = tostring(damageText):match("Damage:%s*([%d%.]+%s*[KMBTQaq]?)")
            if not num then return 0 end
            num = num:gsub("%s+", "")
            local mult = 1
            if num:find("Qa") or num:find("qa") then
                mult = 1000000000000000
                num = num:gsub("[Qq][Aa]", "")
            elseif num:find("T") then
                mult = 1000000000000
                num = num:gsub("T", "")
            elseif num:find("B") then
                mult = 1000000000
                num = num:gsub("B", "")
            elseif num:find("M") then
                mult = 1000000
                num = num:gsub("M", "")
            elseif num:find("K") then
                mult = 1000
                num = num:gsub("K", "")
            end
            return tonumber(num) and tonumber(num) * mult or 0
        end
        
        
        -- Helper: Get weapon GUI damage by weapon name
        local function getWeaponDamageByName(weaponName)
            local guiPath = game:GetService("Players").LocalPlayer.PlayerGui
            local lists = guiPath:FindFirstChild("__Disable") and guiPath.__Disable:FindFirstChild("Menus")
            if not lists then return 0 end
            lists = lists:FindFirstChild("Inventory") and lists.Inventory:FindFirstChild("Main")
            if not lists then return 0 end
            lists = lists:FindFirstChild("Lists") and lists.Lists:FindFirstChild("Weapons")
            if not lists then return 0 end
            local weaponGui = lists:FindFirstChild(weaponName)
            if not weaponGui then return 0 end
            local main = weaponGui:FindFirstChild("Main")
            if not main then return 0 end
            local dmgText = main:FindFirstChild("Damage")
            if not dmgText or not dmgText:IsA("TextLabel") then return 0 end
            return parseDamageText(dmgText.Text)
        end
        
        -- Sell weapons by damage threshold
        local function sellWeaponsByDamage()
            local weaponFolder = player.leaderstats.Inventory:WaitForChild("Weapons")
            local weaponsToSell = {}
            for _, weapon in ipairs(weaponFolder:GetChildren()) do
                local weaponName = weapon.Name
                local damage = getWeaponDamageByName(weaponName)
                if damage > 0 and damage < selectedDamageThreshold then
                    table.insert(weaponsToSell, weaponName)
                    if #weaponsToSell >= 20 then
                        local args = {
                            [1] = {
                                [1] = {
                                    ["Weapons"] = weaponsToSell,
                                    ["Action"] = "Sell",
                                    ["Event"] = "WeaponAction"
                                },
                                [2] = orosbucocugu
                            }
                        }
                        remote:FireServer(unpack(args))
                        print("Sold", #weaponsToSell, "weapons below threshold")
                        task.wait(0.3)
                        weaponsToSell = {}
                    end
                end
            end
            if #weaponsToSell > 0 then
                local args = {
                    [1] = {
                        [1] = {
                            ["Weapons"] = weaponsToSell,
                            ["Action"] = "Sell",
                            ["Event"] = "WeaponAction"
                        },
                        [2] = orosbucocugu
                    }
                }
                remote:FireServer(unpack(args))
                print("Sold", #weaponsToSell, "remaining weapons below threshold")
            end
        end
        
        Tabs.misc:AddButton({
            Title = "Sell Weapons Now",
            Description = "Sell all weapons below selected damage threshold",
            Callback = function()
                sellWeaponsByDamage()
            end
        })
        
        Tabs.misc:AddToggle("AutoSellWeaponToggle", {
            Title = "Auto Sell Weapons (Close Inventory)",
            Default = autoSellWeaponEnabled,
            Callback = function(state)
                autoSellWeaponEnabled = state
                if state then
                    Fluent:Notify({
                        Title = "Auto Sell Weapons enabled",
                        Content = "Will automatically sell weapons below threshold: " .. tostring(selectedDamageThreshold),
                        Duration = 3
                    })
                    task.spawn(function()
                        while autoSellWeaponEnabled do
                            sellWeaponsByDamage()
                            task.wait(5)
                        end
                    end)
                end
            end
        })

        Tabs.misc:AddSection("Enchant Weapon")
     
        local enchantTypes = {
               "FireAspect",
               "VorpalAspect",
               "LootAspect",
               "Sharpness",
               "Vorpal",
               "Loot"
           }
           
           -- Function to get weapon display information from inventory GUI
           local function getWeaponDisplayInfo()
               local playerGui = game:GetService("Players").LocalPlayer.PlayerGui
               local weaponFrames = {}
               local inventoryPath
               
               -- Use pcall to catch errors when trying to access inventory paths
               local success = pcall(function()
                   -- Check both possible inventory GUI locations with safer traversal
                   if playerGui:FindFirstChild("__Disable") then
                       local menus = playerGui.__Disable:FindFirstChild("Menus")
                       if menus and menus:FindFirstChild("Inventory") then
                           local main = menus.Inventory:FindFirstChild("Main")
                           if main and main:FindFirstChild("Lists") then
                               local weapons = main.Lists:FindFirstChild("Weapons")
                               if weapons then
                                   inventoryPath = weapons
                               end
                           end
                       end
                   elseif playerGui:FindFirstChild("Menus") then
                       local inventory = playerGui.Menus:FindFirstChild("Inventory")
                       if inventory and inventory:FindFirstChild("Main") then
                           local lists = inventory.Main:FindFirstChild("Lists")
                           if lists and lists:FindFirstChild("Weapons") then
                               inventoryPath = lists.Weapons
                           end
                       end
                   end
               end)
               
               if not success or not inventoryPath then
                   print("Warning: Could not find inventory path. The inventory might be open or GUI structure has changed.")
                   return {}
               end
               
               -- Collect all weapon information
               for _, weaponFrame in pairs(inventoryPath:GetChildren()) do
               -- Check for both ImageButton and Frame as classnames
               if weaponFrame:IsA("ImageButton") or weaponFrame:IsA("Frame") then
                   local valueText
                   local rankText
                   local damageText
                   
                   -- Try to find value text
                   if weaponFrame:FindFirstChild("Main") and 
                      weaponFrame.Main:FindFirstChild("Value") then
                   valueText = weaponFrame.Main.Value.Text
                   end
                   
                   -- Try to find rank text
                   if weaponFrame:FindFirstChild("Main") and 
                      weaponFrame.Main:FindFirstChild("Rank") then
                   rankText = weaponFrame.Main.Rank.Text
                   end
                   
                   -- Try to find damage text
                   if weaponFrame:FindFirstChild("Main") and 
                      weaponFrame.Main:FindFirstChild("Damage") then
                   damageText = weaponFrame.Main.Damage.Text:gsub("Damage: ", "")
                   end
                   
                   if valueText then
                   local displayName = valueText
                   local rank = rankText or "?"
                   local damage = damageText or "?"
                   local fullDisplay = string.format("%s | Rank: %s | DMG: %s", displayName, rank, damage)
                   
                   -- Store frame name (weapon ID) with display info
                   table.insert(weaponFrames, {
                       displayName = fullDisplay,
                       frameName = weaponFrame.Name,
                       weaponID = weaponFrame.Name  -- This is the actual weapon ID we need
                   })
                   end
               end
               end
               
               return weaponFrames
           end
           
           -- Create a mapping between display names and weapon IDs
           local displayToWeaponID = {}
           
           -- Function to get weapon ID from display name
           local function getWeaponIDFromDisplay(displayName)
               -- Check if we have a cached mapping
               if displayToWeaponID[displayName] then
               return displayToWeaponID[displayName]
               end
               
               -- Get fresh weapon info
               local weapons = getWeaponDisplayInfo()
               
               -- Look for exact match in our weapons list
               for _, weapon in pairs(weapons) do
               if weapon.displayName == displayName then
                   displayToWeaponID[displayName] = weapon.weaponID
                   return weapon.weaponID
               end
               end
               
               -- If we reach here, we need to try alternative methods
               -- Try direct approach from inventory
               local inventory = game:GetService("Players").LocalPlayer.leaderstats.Inventory.Weapons
               
               -- First, try to extract a weapon ID pattern from the display name
               -- Format example: "Hybrid War Axe | Rank: D | DMG: 6.22K"
               local baseName = string.match(displayName, "^(.+) |")
               if baseName then
               -- Look for any weapon in inventory that might match this base name
               for _, weapon in pairs(inventory:GetChildren()) do
                   local weaponName = weapon:GetAttribute("Name")
                   if weaponName and string.find(weaponName, baseName) then
                   displayToWeaponID[displayName] = weapon.Name
                   return weapon.Name
                   end
               end
               end
               
               -- As a last resort, check GUI elements directly
               local playerGui = game:GetService("Players").LocalPlayer.PlayerGui
               local inventoryPaths = {
               playerGui.__Disable and playerGui.__Disable.Menus and playerGui.__Disable.Menus.Inventory and 
                   playerGui.__Disable.Menus.Inventory.Main.Lists.Weapons,
               playerGui.Menus and playerGui.Menus.Inventory and playerGui.Menus.Inventory.Main.Lists.Weapons
               }
               
               for _, path in pairs(inventoryPaths) do
               if path then
                   for _, frame in pairs(path:GetChildren()) do
                   if frame:IsA("ImageButton") or frame:IsA("Frame") then
                       if frame:FindFirstChild("Main") and frame.Main:FindFirstChild("Value") then
                       local frameName = string.format("%s | Rank: %s | DMG: %s", 
                           frame.Main.Value.Text,
                           frame.Main:FindFirstChild("Rank") and frame.Main.Rank.Text or "?",
                           frame.Main:FindFirstChild("Damage") and frame.Main.Damage.Text:gsub("Damage: ", "") or "?"
                       )
                       
                       if frameName == displayName then
                           displayToWeaponID[displayName] = frame.Name
                           return frame.Name
                       end
                       end
                   end
                   end
               end
               end
               
               return nil
           end
           
           -- Function to generate a list of enchant levels
           local function getEnchantLevels()
               local levels = {}
               for i = 1, 9 do
                   table.insert(levels, tostring(i))
               end
               return levels
           end
           
           -- Track selected enchants and levels
           local selectedEnchants = {}
           local selectedLevels = {}
           
           -- Function to check if a weapon has the desired enchants and levels
           local function checkEnchants(weapon)
               -- Safety check to ensure we have valid selections
               if selectedEnchants == nil then selectedEnchants = {} end
               if selectedLevels == nil then selectedLevels = {} end
               
               if #selectedEnchants == 0 or #selectedLevels == 0 then
                   return false
               end
               
               local enchantFolder = weapon:FindFirstChild("Enchants")
               if not enchantFolder then
                   return false
               end
               
               -- Debug current enchants and levels (more verbose for troubleshooting)
               local debugText = "Checking Enchants:\n"
               for _, enchantName in pairs(selectedEnchants) do
                   local currentLevel = enchantFolder:GetAttribute(enchantName)
                   debugText = debugText .. enchantName .. ": " .. (currentLevel or "None") .. "\n"
               end
               
               debugText = debugText .. "Selected Levels: "
               for i, level in ipairs(selectedLevels) do
                   debugText = debugText .. level .. (i < #selectedLevels and ", " or "")
               end
               
               print(debugText)  -- Print debug info to output
               
               -- Check if any of our selected enchants has reached the desired level
               for _, enchantName in pairs(selectedEnchants) do
                   local currentLevel = enchantFolder:GetAttribute(enchantName)
                   
                   -- If this enchant exists
                   if currentLevel then
                       for _, targetLevel in pairs(selectedLevels) do
                           -- Convert both to numbers for proper comparison
                           local numCurrentLevel = tonumber(currentLevel)
                           local numTargetLevel = tonumber(targetLevel)
                           
                           -- FIX: Only stop if the level matches exactly
                           if numCurrentLevel and numTargetLevel and numCurrentLevel == numTargetLevel then
                               -- Found a match: enchant + level meets our criteria
                               Fluent:Notify({
                                   Title = "Enchant Goal Reached",
                                   Content = enchantName .. " level " .. currentLevel .. " found (target: " .. targetLevel .. ")",
                                   Duration = 5
                               })
                               return true
                           end
                       end
                   end
               end
               
               -- No selected enchant with desired level found
               return false
           end
           
           -- Get weapon list - Fixed version
           local function getWeaponList()
               local weapons = {}
               
               -- Try to get weapons from GUI first
               local success, result = pcall(function()
                   return getWeaponDisplayInfo()
               end)
               
               if success then
                   weapons = result
               else
                   print("Warning: Error getting weapon display info: " .. tostring(result))
               end
               
               local displayList = {}
               
               if #weapons == 0 then
                   -- Try direct inventory approach since GUI method failed
                   local success, inventory = pcall(function()
                       return game:GetService("Players").LocalPlayer.leaderstats.Inventory.Weapons
                   end)
                   
                   if not success or not inventory then
                       Fluent:Notify({
                           Title = "Error",
                           Content = "Cannot access inventory. Try closing inventory menu first.",
                           Duration = 5
                       })
                       return {}
                   end
                   
                   -- Add weapons from inventory
                   for _, weapon in pairs(inventory:GetChildren()) do
                       local weaponName = weapon:GetAttribute("Name") or weapon.Name
                       displayList[weaponName] = weaponName
                       
                       -- Add to our weapons reference list
                       table.insert(weapons, {
                           displayName = weaponName,
                           frameName = weapon.Name,
                           weaponID = weapon.Name
                       })
                       
                       -- Update our mapping
                       displayToWeaponID[weaponName] = weapon.Name
                   end
                   
                   -- Fallback: If still empty, just use the weapon folder names
                   if next(displayList) == nil then
                       for _, weapon in pairs(inventory:GetChildren()) do
                           displayList[weapon.Name] = weapon.Name
                           displayToWeaponID[weapon.Name] = weapon.Name
                       end
                   end
               else
                   for _, weapon in pairs(weapons) do
                       displayList[weapon.displayName] = weapon.displayName
                       -- Update our mapping
                       displayToWeaponID[weapon.displayName] = weapon.weaponID
                   end
               end
               
               -- Convert to array for dropdown
               local dropdownList = {}
               for display, _ in pairs(displayList) do
                   table.insert(dropdownList, display)
               end
               
               return dropdownList
           end
           
           -- Initialize UI elements
           local weaponDropdown = Tabs.misc:AddDropdown(
               "EnchantWeapon",
               {
                   Title = "Select Weapon",
                   Values = {},  -- Start with empty values and fill later
                   Multi = false,
                   Default = "",
               }
           )
           
           -- Use pcall when accessing the weapon list
           local success, weapons = pcall(function()
               return getWeaponList()
           end)
           
           if success then
               weaponDropdown:SetValues(weapons)
               
               if #weapons == 0 then
                   Fluent:Notify({
                       Title = "Weapon List Empty",
                       Content = "Try closing inventory menu first, then click 'Refresh Weapon List'",
                       Duration = 5
                   })
               end
           else
               Fluent:Notify({
                   Title = "Error Loading Weapons",
                   Content = "Please close inventory menu and try again",
                   Duration = 5
               })
           end
   
           Tabs.misc:AddButton({
               Title = "Refresh Weapon List",
               Callback = function()
                   local success, weapons = pcall(function()
                       return getWeaponList()
                   end)
                   
                   if success then
                       weaponDropdown:SetValues(weapons)
                       Fluent:Notify({
                           Title = "Weapon List Refreshed",
                           Content = "Found " .. #weapons .. " weapons",
                           Duration = 3
                       })
                   else
                       Fluent:Notify({
                           Title = "Error",
                           Content = "Try closing inventory menu first",
                           Duration = 3
                       })
                   end
               end
           })
           
           local enchantTypeDropdown = Tabs.misc:AddDropdown(
               "EnchantType",
               {
               Title = "Select Enchants",
               Values = enchantTypes,
               Multi = true,
               Default = {},
               }
           )
           
           local enchantLevelDropdown = Tabs.misc:AddDropdown(
               "EnchantLevel", 
               {
                   Title = "Select Levels",
                   Values = getEnchantLevels(),
                   Multi = true,
                   Default = {},
               }
           )
           
           enchantTypeDropdown:OnChanged(function(Value)
               selectedEnchants = {}
               if Value then  -- Ensure Value is not nil
                   for enchant, isSelected in next, Value do
                       if isSelected then
                           table.insert(selectedEnchants, enchant)
                       end
                   end
               end
           end)
           
           enchantLevelDropdown:OnChanged(function(Value)
               selectedLevels = {}
               if Value then  -- Ensure Value is not nil
                   for level, isSelected in next, Value do
                       if isSelected then
                           -- Make sure we store the level as a string
                           table.insert(selectedLevels, level)
                       end
                   end
               end
           end)
           
           -- Auto enchant functionality
           local autoEnchantEnabled = false
           
           local function autoEnchant()
               while autoEnchantEnabled do
                   local selectedDisplay = weaponDropdown.Value
                   if selectedDisplay then
                       -- Get the actual weapon ID using our improved function
                       local weaponID = getWeaponIDFromDisplay(selectedDisplay)
                       
                       if weaponID then
                           -- Use pcall to safely get inventory
                           local success, inventory = pcall(function()
                               return game:GetService("Players").LocalPlayer.leaderstats.Inventory.Weapons
                           end)
                           
                           if not success or not inventory then
                               Fluent:Notify({
                                   Title = "Error",
                                   Content = "Cannot access inventory. Try closing inventory menu first.",
                                   Duration = 3
                               })
                               autoEnchantEnabled = false
                               break
                           end
                           
                           local weapon = inventory:FindFirstChild(weaponID)
                           
                           if weapon then
                               -- Get enchant folder - create it if it doesn't exist
                               local enchantFolder = weapon:FindFirstChild("Enchants")
                               if not enchantFolder then
                                   enchantFolder = Instance.new("Folder")
                                   enchantFolder.Name = "Enchants"
                                   enchantFolder.Parent = weapon
                               end
                               
                               -- Debug the current state of enchants
                               if enchantFolder then
                                   local debugStr = "Current Enchants for " .. weapon.Name .. ":\n"
                                   for _, enchantName in pairs(selectedEnchants) do
                                       local currentLevel = enchantFolder:GetAttribute(enchantName)
                                       debugStr = debugStr .. enchantName .. ": " .. (currentLevel or "None") .. "\n"
                                   end
                                   print(debugStr)
                               end
                               
                               -- Check if the weapon already has the desired enchants and levels
                               if checkEnchants(weapon) then
                                   -- If the weapon has the desired enchants, stop auto enchanting
                                   autoEnchantEnabled = false
                                   Fluent:Notify({
                                       Title = "Auto Enchant Success",
                                       Content = "Desired enchant level reached! Stopping enchant.",
                                       Duration = 5
                                   })
                                   break
                               else
                                   -- If not, perform the enchant
                                   local args = {
                                       [1] = {
                                           [1] = {
                                               ["Weapon"] = weaponID,
                                               ["Event"] = "EnchantWeapon",
                                               ["BuyType"] = "Gems"
                                           },
                                           [2] = orosbucocugu
                                       }
                                   }
                                   game:GetService("ReplicatedStorage").BridgeNet2.dataRemoteEvent:FireServer(unpack(args))
                                   
                                   -- Add a small delay to check enchants after firing
                                   task.wait(0.5)
                                   
                                   -- Re-check if we got the desired enchant - force a refresh first
                                   inventory = game:GetService("Players").LocalPlayer.leaderstats.Inventory.Weapons
                                   weapon = inventory:FindFirstChild(weaponID)
                                   
                                   if weapon and checkEnchants(weapon) then
                                       autoEnchantEnabled = false
                                       Fluent:Notify({
                                           Title = "Auto Enchant Success",
                                           Content = "Desired enchant level reached!",
                                           Duration = 5
                                       })
                                       break
                                   end
                               end
                           else
                               Fluent:Notify({
                                   Title = "Error",
                                   Content = "Weapon not found in inventory! Try refreshing weapon list.",
                                   Duration = 3
                               })
                               task.wait(1)
                           end
                       else
                           Fluent:Notify({
                               Title = "Error",
                               Content = "Could not get weapon ID! Try refreshing weapon list.",
                               Duration = 3
                           })
                           autoEnchantEnabled = false
                       end
                   else
                       Fluent:Notify({
                           Title = "Error",
                           Content = "No weapon selected!",
                           Duration = 3
                       })
                       autoEnchantEnabled = false
                   end
                   task.wait(0.2)
               end
           end
           
           -- Add toggle for auto enchant
           Tabs.misc:AddToggle(
               "AutoEnchant",
               {
               Title = "Auto Enchant",
               Default = false,
               Callback = function(state)
                   autoEnchantEnabled = state
                   if state then
                   if #selectedEnchants == 0 or #selectedLevels == 0 then
                       Fluent:Notify({
                       Title = "Auto Enchant",
                       Content = "Please select at least one enchant and level!",
                       Duration = 5
                       })
                       return
                   end
                   task.spawn(autoEnchant)
                   end
               end
               }
           )

        local locations = {
            {Name = "Location 1", CFrame = CFrame.new(-6161.25781, 140.639832, 5512.9668)},
            {Name = "Location 2", CFrame = CFrame.new(-5868.44141, 132.70488, 362.519379)},
            {Name = "Location 3", CFrame = CFrame.new(-5430.81006, 107.441559, -5502.25244)},
            {Name = "Location 4", CFrame = CFrame.new(-702.243225, 133.344467, -3538.11646)},
            {Name = "Location 5", CFrame = CFrame.new(450.001709, 117.564827, 3435.4292)},
            {Name = "Location 6", CFrame = CFrame.new(3230.96826, 135.41008, 36.1600113)},
            {Name = "Location 7", CFrame = CFrame.new(4325.36523, 118.995422, -4819.78857)}
        }
        
        local PlaceID = game.PlaceId
        local AllIDs = {}
        local foundAnything = ""
        local actualHour = os.date("!*t").hour
        local File =
            pcall(
            function()
                AllIDs = game:GetService("HttpService"):JSONDecode(readfile("NotSameServers.json"))
            end
        )
        
        if not File then
            table.insert(AllIDs, actualHour)
            writefile("NotSameServers.json", game:GetService("HttpService"):JSONEncode(AllIDs))
        end
        
        function TPReturner()
            local Site
            if foundAnything == "" then
                Site =
                    game.HttpService:JSONDecode(
                    game:HttpGet("https://games.roblox.com/v1/games/" .. PlaceID .. "/servers/Public?sortOrder=Asc&limit=100")
                )
            else
                Site =
                    game.HttpService:JSONDecode(
                    game:HttpGet(
                        "https://games.roblox.com/v1/games/" ..
                            PlaceID .. "/servers/Public?sortOrder=Asc&limit=100&cursor=" .. foundAnything
                    )
                )
            end
            local ID = ""
            if Site.nextPageCursor and Site.nextPageCursor ~= "null" and Site.nextPageCursor ~= nil then
                foundAnything = Site.nextPageCursor
            end
            local num = 0
            for _, v in pairs(Site.data) do
                local Possible = true
                ID = tostring(v.id)
                if tonumber(v.maxPlayers) > tonumber(v.playing) then
                    for _, Existing in pairs(AllIDs) do
                        if num ~= 0 then
                            if ID == tostring(Existing) then
                                Possible = false
                            end
                        else
                            if tonumber(actualHour) ~= tonumber(Existing) then
                                local delFile =
                                    pcall(
                                    function()
                                        delfile("NotSameServers.json")
                                        AllIDs = {}
                                        table.insert(AllIDs, actualHour)
                                    end
                                )
                            end
                        end
                        num = num + 1
                    end
                    if Possible then
                        table.insert(AllIDs, ID)
                        wait()
                        pcall(
                            function()
                                writefile("NotSameServers.json", game:GetService("HttpService"):JSONEncode(AllIDs))
                                wait()
                                -- autoexec ile ilgili kodlar kaldırıldı
                                game:GetService("TeleportService"):TeleportToPlaceInstance(PlaceID, ID, Players.LocalPlayer)
                            end
                        )
                        wait(4)
                        break
                    end
                end
            end
        end
        
        local function getUniquePetNames()
            local pets = {}
            local seenNames = {} -- To track unique names
        
            local playerPets = game:GetService("Players").LocalPlayer.leaderstats.Inventory.Pets:GetChildren()
            print("Fetching pets...") -- DEBUG
        
            for _, pet in ipairs(playerPets) do
                local petName = pet:GetAttribute("Name") -- Get "Name" attribute
                if petName then
                    print("Found Pet:", petName) -- DEBUG
                    if not seenNames[petName] then
                        table.insert(pets, petName)
                        seenNames[petName] = true -- Mark name as seen
                    end
                end
            end
            return pets
        end
        
        -- Populate dropdown with **unique** pet names
        
        local autoEquipEnabled = false
        
        local function EquipBestPets()
            local petsFolder = player.leaderstats.Inventory.Pets
            local maxEquip = player.leaderstats.Values:GetAttribute("MaxEquipPets") or 1
            local bestPets = {}
        
            local petsList = {}
            for _, pet in ipairs(petsFolder:GetChildren()) do
                local rank = pet:GetAttribute("Rank")
                if rank and typeof(rank) == "number" then
                    table.insert(petsList, {name = pet.Name, rank = rank})
                end
            end
        
            table.sort(
                petsList,
                function(a, b)
                    return a.rank > b.rank
                end
            )
        
            local equipCount = 0
            for _, petData in ipairs(petsList) do
                if equipCount < maxEquip then
                    table.insert(bestPets, petData.name)
                    equipCount = equipCount + 1
                else
                    break
                end
            end
        
            if #bestPets > 0 then
                game:GetService("ReplicatedStorage"):WaitForChild("BridgeNet2"):WaitForChild("dataRemoteEvent"):FireServer(
                    {
                        {["Event"] = "EquipBest", ["Pets"] = bestPets},
                        degisiklik2
                    }
                )
            end
        end
        
        local Toggle = Tabs.pets:AddToggle("AutoEquip", {Title = "Auto Equip Best Pets", Default = false})
        
        Toggle:OnChanged(
            function(state)
                autoEquipEnabled = state
                if state then
                    --Fluent:Notify({Title = "Auto Equip", Content = "Enabled. Equipping every 2 minutes.", Duration = 5})
                    task.spawn(
                        function()
                            while autoEquipEnabled do
                                EquipBestPets()
                                wait(120)
                            end
                        end
                    )
                else
                    --Fluent:Notify({Title = "Auto Equip", Content = "Disabled.", Duration = 5})
                end
            end
        )
        
        local targetCFrame =
            CFrame.new(
            3648.76318,
            223.552261,
            2637.36719,
            0.846323907,
            7.72367986e-18,
            -0.532668591,
            -1.10462046e-17,
            1,
            -3.05065368e-18,
            0.532668591,
            8.46580728e-18,
            0.846323907
        )
        
        local function tweenToPivot()
            hrp.CFrame = targetCFrame
        end
        
        local function tweenCharacter(targetCFrame)
            if player and player.Character and player.Character:FindFirstChild("HumanoidRootPart") then
                local hrp = player.Character.HumanoidRootPart
                local tweenService = game:GetService("TweenService")
                local tweenInfo = TweenInfo.new(3, Enum.EasingStyle.Quad, Enum.EasingDirection.Out)
                local tween = tweenService:Create(hrp, tweenInfo, {CFrame = targetCFrame})
                tween:Play()
            end
        end
        
        Tabs.tp:AddSection("Dedu Island")
        Tabs.tp:AddButton(
            {
                Title = "Tween to Dedu Island",
                Description = "Smoothly moves your character",
                Callback = function()
                    tweenCharacter(
                        CFrame.new(
                            3859.06299,
                            60.1228409,
                            3081.9458,
                            -0.987112403,
                            6.46206388e-07,
                            -0.160028473,
                            5.63319077e-07,
                            1,
                            5.63319418e-07,
                            0.160028473,
                            4.65912507e-07,
                            -0.987112403
                        )
                    ) -- Change this to your desired position
                end
            }
        )
        
 
Tabs.Exchange:AddSection("Exchange Shop")
 
local autoExchangeEnabled = false
local selectedExchangeItem = nil 
local exchangeAmount = 1 
local exchangeDelay = 0.5 

local exchangeItems = {
    "x1 Rare => x1 Common",
    "x5 Common => x1 Rare",
    "x1 Legendary => x1 Rare",
    "x5 Rare => x1 Legendary",
    "x10 Rank Up Rune => x1 Ultimate Rank Up Rune"
}

local itemMapping = {
    ["x1 Rare => x1 Common"] = "EnchCommon",
    ["x5 Common => x1 Rare"] = "EnchRare",
    ["x1 Legendary => x1 Rare"] = "EnchRare2",
    ["x5 Rare => x1 Legendary"] = "EnchLegendary",
    ["x10 Rank Up Rune => x1 Ultimate Rank Up Rune"] = "DgURankUpRune"
}

Tabs.Exchange:AddDropdown("ExchangeItem", {
    Title   = "Select Item",
    Values  = exchangeItems,
    Default = "",
    Callback = function(Value)
        selectedExchangeItem = itemMapping[Value]
    end
})

Tabs.Exchange:AddSlider("ExchangeAmount", {
    Title   = "Amount",
    Default = exchangeAmount,
    Min     = 1, Max = 100, Rounding = 0.1,
    Callback = function(Value)
        exchangeAmount = Value
    end
})

Tabs.Exchange:AddSlider("ExchangeDelay", {
    Title   = "Delay",
    Default = 1,
    Min = 0.1, 
    Max = 10, 
    Rounding = 0.1,
    Callback = function(Value)
        exchangeDelay = Value
    end
})

Tabs.Exchange:AddToggle("AutoExchange", {
    Title   = "Auto Exchange",
    Default = false,
    Callback = function(state)
        autoExchangeEnabled = state
        if state then
            task.spawn(function()
                if not selectedExchangeItem then
                    autoExchangeEnabled = false
                    return
                end
                while autoExchangeEnabled do
                    local args = {
                        [1] = {
                            [1] = {
                                ["Shop"]   = "ExchangeShop",
                                ["Action"] = "Buy",
                                ["Amount"] = exchangeAmount,
                                ["Event"]  = "ItemShopAction",
                                ["Item"]   = selectedExchangeItem
                            },
                            [2] = orosbucocugu
                        }
                    }
                    game:GetService("ReplicatedStorage")
                        :WaitForChild("BridgeNet2")
                        :WaitForChild("dataRemoteEvent")
                        :FireServer(unpack(args))

                    task.wait(exchangeDelay)
                end
            end)
        end
    end
})

        local function usePotion(potionName)
            if not autoPotionEnabled then return end
            
            local args = {
                [1] = {
                    [1] = {
                        ["Event"] = "UseItem",
                        ["Name"] = potionName,
                        ["Action"] = "Use"
                    },
                    [2] = orosbucocugu
                }
            }
            
            game:GetService("ReplicatedStorage").BridgeNet2.dataRemoteEvent:FireServer(unpack(args))
        end

        task.spawn(function()
            while true do
                if autoPotionEnabled and #selectedPotions > 0 then
                    for _, potion in ipairs(selectedPotions) do
                        usePotion(potion)
                    end
                end
                task.wait(1)
            end
        end)
        
        Tabs.Potion:AddSection("Potion System")

         Tabs.Potion:AddToggle(
            "AutoPotion",
            {
                Title = "Auto Use Potion",
                Default = false,
                Callback = function(state)
                    autoPotionEnabled = state
                end
            }
        )

         Tabs.Potion:AddDropdown(
            "PotionSelection",
            {
                Title = "Select Potions",
                Values = POTION_TYPES,
                Multi = true,
                Default = {},
                Callback = function(Value)
                    selectedPotions = {}
                    for potion, isSelected in pairs(Value) do
                        if isSelected then
                            table.insert(selectedPotions, potion)
                        end
                    end
                end
            }
        )
        
        Tabs.Level:AddSection("Stat Upgrade")
        
        local statNames = {
            "ShadowDamage",
            "ShadowSpeed",
            "WeaponDamage",
            "PlayerSpeed",
            "ShadowRange"
        }
        
        local pointsList = {}
        for i = 1, 10 do table.insert(pointsList, tostring(i)) end
        
        local selectedStats = {}
        local selectedPoints = 1
        local autoStatUpgrade = false
        
        Tabs.Level:AddDropdown("StatMultiDropdown", {
            Title = "Select Stats",
            Values = statNames,
            Multi = true,
            Default = {},
            Callback = function(val)
                selectedStats = {}
                for stat, enabled in pairs(val) do
                    if enabled then table.insert(selectedStats, stat) end
                end
            end
        })
        
        Tabs.Level:AddDropdown("PointsDropdown", {
            Title = "Points",
            Values = pointsList,
            Multi = false,
            Default = "1",
            Callback = function(val)
                selectedPoints = tonumber(val)
            end
        })
        
        Tabs.Level:AddToggle("AutoStatUpgradeToggle", {
            Title = "Auto Upgrade Selected Stats",
            Default = false,
            Callback = function(state)
                autoStatUpgrade = state
                if state then
                    task.spawn(function()
                        while autoStatUpgrade do
                            for _, stat in ipairs(selectedStats) do
                                local args = {
                                    [1] = {
                                        [1] = {
                                            ["Stats"] = stat,
                                            ["Event"] = "StatsUp",
                                            ["Points"] = selectedPoints
                                        },
                                        [2] = orosbucocugu
                                    }
                                }
                                game:GetService("ReplicatedStorage").BridgeNet2.dataRemoteEvent:FireServer(unpack(args))
                                task.wait(0.2)
                            end
                            task.wait(1)
                        end
                    end)
                end
            end
        })
       
        Tabs.Webhook:AddInput("WebhookURLInput", {
            Title = "Webhook URL",
            Description = "Enter the webhook URL to send dungeon data",
            Default = "",
            Placeholder = "https://discord.com/api/webhooks/your-webhook-id",
            Numeric = false,
            Finished = true,
            Callback = function(value)
                _G.webhookUrl = value
            end
        })
        
        Tabs.Webhook:AddToggle("EnableWebhook", {
            Title = "Enable Dungeon Join Webhook",
            Description = "Toggle sending dungeon info to webhook",
            Default = false,
            Callback = function(state)
                _G.webhookEnabled = state
            end
        })

        

        getgenv().Image = "rbxassetid://14867516798"
        getgenv().ToggleUI = "LeftControl"
        
        task.spawn(
            function()
                if not getgenv().LoadedMobileUI == true then
                    getgenv().LoadedMobileUI = true
                    local OpenUI = Instance.new("ScreenGui")
                    local ImageButton = Instance.new("ImageButton")
                    local UICorner = Instance.new("UICorner")
                    OpenUI.Name = "OpenUI"
                    OpenUI.Parent = game:GetService("CoreGui")
                    OpenUI.ZIndexBehavior = Enum.ZIndexBehavior.Sibling
                    ImageButton.Parent = OpenUI
                    ImageButton.BackgroundColor3 = Color3.fromRGB(105, 105, 105)
                    ImageButton.BackgroundTransparency = 0.8
                    ImageButton.Position = UDim2.new(0.9, 0, 0.1, 0)
                    ImageButton.Size = UDim2.new(0, 50, 0, 50)
                    ImageButton.Image = getgenv().Image
                    ImageButton.Draggable = true
                    ImageButton.Transparency = 1
                    UICorner.CornerRadius = UDim.new(0, 200)
                    UICorner.Parent = ImageButton
                    ImageButton.MouseButton1Click:Connect(
                        function()
                            game:GetService("VirtualInputManager"):SendKeyEvent(true, getgenv().ToggleUI, false, game)
                        end
                    )
                end
            end
        )
        
        game:GetService("Players").LocalPlayer.Idled:connect(function()
            game:GetService("VirtualUser"):CaptureController()
            game:GetService("VirtualUser"):ClickButton2(Vector2.new())
            wait(1)
        end)

            game:GetService("Players").LocalPlayer.Idled:connect(function()
            VirtualUser:Button2Down(Vector2.new(0, 0), workspace.CurrentCamera.CFrame)
            wait(1)
            VirtualUser:Button2Up(Vector2.new(0, 0), workspace.CurrentCamera.CFrame)
        end)
        
        Tabs.Settings:AddSection("Settings")
        Tabs.Settings:AddButton({
            Title = "Rejoin",
            Description = "Rejoin the same game server",
            Callback = function()
                game:GetService("TeleportService"):Teleport(game.PlaceId, game.Players.LocalPlayer)
            end
        })
        
        Tabs.Settings:AddButton({
            Title = "Server Hop",
            Description = "Hop to a different server",
            Callback = function()
                TPReturner()
            end
        })
        
        local autoMinimizeUI = false
        Tabs.Settings:AddToggle("AutoMinimizeUI", {
            Title = "Auto Minimize UI on Start",
            Description = "Automatically minimizes the UI when the script starts.",
            Default = false,
            Callback = function(val)
                autoMinimizeUI = val
            end
        })
        
        Tabs.Settings:AddButton({
            Title = "Reset All Configs",
            Description = "Deletes all saved configurations",
            Callback = function()
                if isfolder(perfectusfolder) then
                    if isfolder(perfectusfolder .. "/AriseCrossover") then
                        delfolder(perfectusfolder .. "/AriseCrossover")
                    end

                    if #listfiles(perfectusfolder) == 0 then
                        delfolder(perfectusfolder)
                    end
                    
                    Fluent:Notify({
                        Title = "Config Reset",
                        Content = "All configurations have been deleted (restart fluent to see changes)",
                        Duration = 3
                    })
                else
                    Fluent:Notify({
                        Title = "Config Reset",
                        Content = "No configurations found to delete",
                        Duration = 3
                    })
                end
            end
        })
        
     
Tabs.Settings:AddSection("Script Settings")


_G.AriseSettings = _G.AriseSettings or {
    Toggles = {
        AutoReinject = false
    }
}

local queueteleport = (syn and syn.queue_on_teleport) or 
                     queue_on_teleport or 
                     (fluxus and fluxus.queue_on_teleport) or
                     (shadow_env and shadow_env.queue_on_teleport) or
                     (krnl and krnl.queue_on_teleport) or
                     (sirhurt and sirhurt.queue_on_teleport) or
                     (oxygen and oxygen.queue_on_teleport) or
                     (sentinel and sentinel.queue_on_teleport) or
                     (hookfunction and hookfunction.queue_on_teleport) or
                     (getgenv().queue_on_teleport)
if not queueteleport then
    warn("Auto-execute için desteklenen bir queue_on_teleport fonksiyonu bulunamadı!")
    queueteleport = function(x) 
        warn("queue_on_teleport desteklenmiyor - auto-execute çalışmayacak") 
    end
end

local TeleportCheck = false

Tabs.Settings:AddToggle("AutoReinjectToggle", {
    Title = "Auto Execute on Teleport",
    Description = "",
    Default = _G.AriseSettings.Toggles.AutoReinject or false,
    Callback = function(Value)
        _G.AriseSettings.Toggles.AutoReinject = Value
        if Value then
            print("Auto Execute enabled. The script will automatically run after teleport.")
        else
            print("Auto Execute disabled.")
        end
    end
})

player.OnTeleport:Connect(function(State)
    if _G.AriseSettings.Toggles.AutoReinject and not TeleportCheck and queueteleport then
        TeleportCheck = true
        queueteleport([[
            spawn(function()
                pcall(function()
                    print("Script loading...")
                    local success, error_message = pcall(function()
                        loadstring(game:HttpGet('https://raw.githubusercontent.com/perfectusmim1/Hub/refs/heads/main/Key'))()
                    end)
                    
                    if not success then
                        warn("An error occurred while loading the script: " .. tostring(error_message))
                    end
                end)
            end)
        ]])
    end
end)
        task.spawn(function()
            task.wait(1)
            if (Fluent.Options.AutoMinimizeUI and Fluent.Options.AutoMinimizeUI.Value) or autoMinimizeUI then
                pcall(function()
                    game:GetService("VirtualInputManager"):SendKeyEvent(true, Enum.KeyCode.LeftControl, false, game)
                    task.wait(0.1)
                    game:GetService("VirtualInputManager"):SendKeyEvent(false, Enum.KeyCode.LeftControl, false, game)
                        Fluent:Notify({
                        Title = "Hide UI",
                        Content = "Auto hidden.",
                        Duration = 3
                    })
                end)
            end
        end)

SaveManager:SetLibrary(Fluent)
InterfaceManager:SetLibrary(Fluent)
SaveManager:IgnoreThemeSettings()
SaveManager:SetIgnoreIndexes({})
InterfaceManager:SetFolder(perfectusfolder)
SaveManager:SetFolder(perfectusfolder .. "/AriseCrossover")
InterfaceManager:BuildInterfaceSection(Tabs.Settings)
SaveManager:BuildConfigSection(Tabs.Settings)

Window:SelectTab(1)
SaveManager:LoadAutoloadConfig()

task.spawn(function()
    task.wait(0.1)
end)
    end)
end

task.spawn(function()
    task.wait(0.1)
    populateTabs()
end)
